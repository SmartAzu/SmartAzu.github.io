<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker学习记录_2</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>系统：Ubuntu 22.04 LTS </p><h3 id="确保下载源安全性："><a href="#确保下载源安全性：" class="headerlink" title="确保下载源安全性："></a>确保下载源安全性：</h3><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># 添加使用HTTPS传输的软件包以及CA证书</span><br>$ sudo apt-get update<br><br>$ sudo apt-get install <span class="hljs-string">\</span><br>    apt-transport-https <span class="hljs-string">\</span><br>    ca-certificates <span class="hljs-string">\</span><br>    curl <span class="hljs-string">\</span><br>    gnupg <span class="hljs-string">\</span><br>    lsb-release<br></code></pre></td></tr></table></figure><h3 id="鉴于国内网络问题，修改为镜像源为国内源："><a href="#鉴于国内网络问题，修改为镜像源为国内源：" class="headerlink" title="鉴于国内网络问题，修改为镜像源为国内源："></a>鉴于国内网络问题，修改为镜像源为国内源：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 添加阿里源及软件源的GPG密钥</span><br>$ curl -fsSL https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/ubuntu/g</span>pg | sudo gpg --dearmor -o <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/keyrings/</span>docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">向 sources.list 中添加 Docker 软件源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure><h3 id="更新apt软件包缓存："><a href="#更新apt软件包缓存：" class="headerlink" title="更新apt软件包缓存："></a>更新apt软件包缓存：</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h3 id="安装Docker-ce："><a href="#安装Docker-ce：" class="headerlink" title="安装Docker-ce："></a>安装Docker-ce：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sudo apt-<span class="hljs-built_in">get</span> install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><h3 id="启动Docker："><a href="#启动Docker：" class="headerlink" title="启动Docker："></a>启动Docker：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl start docker</span><br></code></pre></td></tr></table></figure><h3 id="建立Docker用户组："><a href="#建立Docker用户组：" class="headerlink" title="建立Docker用户组："></a>建立Docker用户组：</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><h3 id="建立-docker-组："><a href="#建立-docker-组：" class="headerlink" title="建立 docker 组："></a>建立 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> groupadd docker</span><br></code></pre></td></tr></table></figure><h3 id="将当前用户加入-docker-组："><a href="#将当前用户加入-docker-组：" class="headerlink" title="将当前用户加入 docker 组："></a>将当前用户加入 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ docker run <span class="hljs-comment">--rm hello-world</span><br><br>Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling <span class="hljs-built_in">from</span> library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:<span class="hljs-number">308866</span>a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello <span class="hljs-built_in">from</span> Docker!<br>This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.<br><br>To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:<br> <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.<br> <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">&quot;hello-world&quot;</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.<br>    (amd64)<br> <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span><br>    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.<br> <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span><br>    <span class="hljs-built_in">to</span> your terminal.<br><br>To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:<br> $ docker run -<span class="hljs-keyword">it</span> ubuntu bash<br><br>Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:<br> <span class="hljs-keyword">https</span>://hub.docker.com/<br><br>For more examples <span class="hljs-keyword">and</span> ideas, visit:<br> <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_1</title>
    <link href="/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）:"></a>镜像（image）:</h3><p>众所周知，操作系统分为内核和用户空间（linux系统一切皆文件）。内核启动后，会挂载root文件系统为其提供用户空间支持。Docker的镜像，就相当于是一个root文件系统。<br>分层存储的概念：<br>镜像本身包含完整的root文件，体积往往是庞大的。Docker为了解决这种问题，在设计时充分利用Union Fs技术，将其设计为分层存储的架构。（ 因为多个镜像可以共享相同的基础层。例如，如果你有多个基于同一操作系统的镜像，这些镜像就可以共享这个操作系统层。）<br>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<br>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h4 id="简单比喻"><a href="#简单比喻" class="headerlink" title="简单比喻"></a>简单比喻</h4><p>可以把 Docker 镜像想象成一本书：<br>● 基础镜像 是书的第一个版本，只读的。<br>● 应用层 是你在第一个版本上增加的注释，还是只读的。<br>● 配置层 是你在前面的基础上又增加的更多注释，仍然只读。<br>● 容器 是你从这本书的最后一个版本上复印了一份，你可以在上面随便写东西（可写层）。<br>这个过程节省了很多纸张（空间），因为你的注释（修改）只是增加了几页，而不是重新写了一本书。</p><h2 id="容器（container）："><a href="#容器（container）：" class="headerlink" title="容器（container）："></a>容器（container）：</h2><p>镜像和容器之间的关系，就像面向对象中的类和实例一样。（类是一种模板，定义了对象属性和行为，它不真实存在。实例是根据类创建的具体对象，它具备类的属性和行为，并且真实存在。）<br>打个比方，车是一个类，具体到实例就是什么车，什么颜色，什么发动机等。<br>容器的实质是进程，但与在宿主机直接执行的进程不同，容器的进程有自己独立的命名空间。正因如此，容器可以拥有自己的root文件系统，各项配置都是独立的。容器内的进程是运行在一个隔离的环境里，使用起来就像一个独立的操作系统一样。这种特性借鉴了沙箱，也使得容器封装的应用比直接运行在宿主机更加安全。</p><p>容器与虚拟机之间的区别，虚拟机是一个完整的操作系统，而容器只是一个运行在宿主机上，拥有独立命令空间的进程。<br>● 虚拟机：提供完整的操作系统环境，资源开销大，启动慢，但隔离性强，适用于需要高度隔离和安全的场景。<br>● 容器：共享操作系统内核，资源开销小，启动快，但隔离性相对较弱，适用于轻量级、快速部署和需要高密度计算的场景。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id="Docker中的镜像和容器"><a href="#Docker中的镜像和容器" class="headerlink" title="Docker中的镜像和容器"></a>Docker中的镜像和容器</h3><p>● 镜像（Image）：镜像就像类，是一个模板，定义了应用程序及其运行环境的所有内容。它是一个只读的文件系统层，用于创建容器。<br>● 容器（Container）：容器就像实例，是镜像的一个具体实现。它是一个运行时的实例，具有镜像的所有特性，并且可以进行实际操作和修改。</p><h2 id="仓库（repository）："><a href="#仓库（repository）：" class="headerlink" title="仓库（repository）："></a>仓库（repository）：</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><h3 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h3><p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder&#x2F;nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-服务："><a href="#Docker-Registry-服务：" class="headerlink" title="Docker Registry 服务："></a>Docker Registry 服务：</h3><p>公有：<br>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。<br>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。除此以外，还有 Red Hat 的 Quay.io；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务；代码托管平台 GitHub 推出的 ghcr.io。<br>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。<br>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。<br>私有：<br>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。<br>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。<br>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="Docker对比传统虚拟化有什么优势？"><a href="#Docker对比传统虚拟化有什么优势？" class="headerlink" title="Docker对比传统虚拟化有什么优势？"></a>Docker对比传统虚拟化有什么优势？</h2><p>Docker相较于传统虚拟化相比有以下优势</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><p>特性        容器            虚拟机<br>启动        秒级            分钟级<br>硬盘使用    一般为 MB        一般为 GB<br>性能        接近原生        弱于<br>系统支持量    单机支持上千个容器 一般几十个</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zabbix学习记录_1</title>
    <link href="/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是zabbix？"><a href="#什么是zabbix？" class="headerlink" title="什么是zabbix？"></a>什么是zabbix？</h2><p>zabbix是一个监控软件，其可以监控各种网络参数，保证企业服务架构安全运营，同时支持灵活的告警机制，可以使得运维人员快速定位故障、解决问题。zabbix支持分布式功能，支持复杂架构下的监控解决方案，也支持web页面，为主机监控提供了良好直观的展现。<br>zabbix官网地址为<a href="https://www.zabbix.com/">https://www.zabbix.com/</a></p><h2 id="zabbix组成"><a href="#zabbix组成" class="headerlink" title="zabbix组成"></a>zabbix组成</h2><h3 id="zabbix-server"><a href="#zabbix-server" class="headerlink" title="zabbix server"></a>zabbix server</h3><p>概念：核心组件，内部存储了所有的配置信息、统计信息和操作信息。zabbix agent会向zabbix server报告可用性、完整性及其他统计信息。</p><h3 id="web页面"><a href="#web页面" class="headerlink" title="web页面"></a>web页面</h3><p>web页面属于zabbix的一部分，通过图形化界面直观展示了监控信息，方便运维人员监控管理。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>zabbix使用数据库，存储监控数据。</p><h3 id="zabbix-proxy"><a href="#zabbix-proxy" class="headerlink" title="zabbix proxy"></a>zabbix proxy</h3><p>这里不得不说到zabbix的三种部署方式，server-client，server-proxy-client，server-node-client，在不同网络架构下部署不同的模式，具体差别请自行搜索，这里不再赘述。<br>zabbix proxy可以根据具体生产环境进行采用或者放弃。如果使用了zabbix proxy，则其会替代zabbix server采集数据信息，可以很好的分担zabbix server的负载。zabbix proxy通常运用与架构过大、zabbix server负载过重，或者是企业设备跨机房、跨网段、zabbix server无法与zabbix agent直接通信的场景。</p><h3 id="zabbix-Agent"><a href="#zabbix-Agent" class="headerlink" title="zabbix Agent"></a>zabbix Agent</h3><p>zabbix agent通常部署在被监控目标上，用于主动监控本地资源和应用程序，并将监控的数据发送给zabbix server。</p><h2 id="zabbix是怎样工作的？"><a href="#zabbix是怎样工作的？" class="headerlink" title="zabbix是怎样工作的？"></a>zabbix是怎样工作的？</h2><p>zabbix在进行监控时，agent作为zabbix客户端被安装在被监控设备上，负责定期收集数据并将其转发给zabbix服务端，服务端的主要工作是存储数据及提供web服务。<br>zabbix的数据收集分为两种模式：</p><h3 id="1、主动"><a href="#1、主动" class="headerlink" title="1、主动"></a>1、主动</h3><p>客户端主动向服务端请求监控项列表，并主动将收集到的数据提交给服务端。</p><h3 id="2、被动"><a href="#2、被动" class="headerlink" title="2、被动"></a>2、被动</h3><p>由服务端向客户端发起请求监控项列表，随后客户端返回信息到服务端。</p><p>主被关系均以zabbix客户端为基准</p><h2 id="zabbix的工作进程有哪些？"><a href="#zabbix的工作进程有哪些？" class="headerlink" title="zabbix的工作进程有哪些？"></a>zabbix的工作进程有哪些？</h2><p>在默认的情况下，zabbix有6个工作进程；分别是 zabbix_agentd，zabbix_get，zabbix_proxy，zabbix_sender，zabbix_server 和 zabbix_gateway。<br>其中，zabbix_java_gateway是可选进程。（监控JMX虚拟机）</p><h3 id="1、zabbix-agentd"><a href="#1、zabbix-agentd" class="headerlink" title="1、zabbix_agentd"></a>1、zabbix_agentd</h3><p>zabbix-agentd为zabbix客户端守护进程 ，主要负责收集客户端监控项数据。</p><h3 id="2、zabbix-server"><a href="#2、zabbix-server" class="headerlink" title="2、zabbix_server"></a>2、zabbix_server</h3><p>zabbix_server为zabbix服务端守护进程，主要负责收集zabbix客户端数据。（端口为10051）（固定端口吗？）</p><h3 id="3、zabbix-proxy"><a href="#3、zabbix-proxy" class="headerlink" title="3、zabbix_proxy"></a>3、zabbix_proxy</h3><p>zabbix_proxy是zabbix的代理程序，其功能类似于server，作用上类似于一个中转站，最终会把收集的数据再次提交给zabbix_server。</p><h3 id="4、zabbix-get"><a href="#4、zabbix-get" class="headerlink" title="4、zabbix_get"></a>4、zabbix_get</h3><p>zabbix_get作为zabbix工具，通常运行在zabbix_server或者zabbix_proxy上，用于远程获取客户端信息，通常用于排错。</p><h3 id="5、zabbix-sender"><a href="#5、zabbix-sender" class="headerlink" title="5、zabbix_sender"></a>5、zabbix_sender</h3><p>zabbix_sender也是zabbix的一个工具，通常运行在zabbix的客户端，用于耗时比较长的检查，其作用是主动发送数据。</p><h3 id="6、zabbix-java-gateway"><a href="#6、zabbix-java-gateway" class="headerlink" title="6、zabbix_java_gateway"></a>6、zabbix_java_gateway</h3><p>zabbix_java_gateway是zabbix2.0以后引入的新功能，可以用于JAVA方面的设备；但是只能主动获取数据，而不能被动获取数据。</p><h2 id="zabbix具体能有哪些监控？"><a href="#zabbix具体能有哪些监控？" class="headerlink" title="zabbix具体能有哪些监控？"></a>zabbix具体能有哪些监控？</h2><p>硬件监控：通过IPMI接口进行监控，监控对象的物理特征，如电压、温度、风扇状态、电源状态等<br>系统监控：zabbix agent interface，通过专用的代理程序进行监控，与常见的master&#x2F;agent模式类似，如果被监控对象支持对应的agent，推荐首选这种模式<br>java监控：zabbix JMX interface，通过JMX进行监控，JMX(java扩展管理)，通常用于监控JVM虚拟机<br>网络设备监控：zabbix snmp interface，通过snmp协议与被监控对象进行通信，通常来讲，无法在如路由器，交换机这种网络设备上安装agent，但是这些设备通常都支持snmp协议<br>应用服务监控、MYSQL数据库监控、URL监控<br>网络设备监控，系统监控，硬件监控为重点。</p><h2 id="zabbix的常用术语"><a href="#zabbix的常用术语" class="headerlink" title="zabbix的常用术语"></a>zabbix的常用术语</h2><h3 id="1、主机（host）"><a href="#1、主机（host）" class="headerlink" title="1、主机（host）"></a>1、主机（host）</h3><p>要监控的设备，可以由IP或者是主机名（必须可解析）指定。</p><h3 id="2、主机组（host-group）"><a href="#2、主机组（host-group）" class="headerlink" title="2、主机组（host group）"></a>2、主机组（host group）</h3><p>主机的逻辑容器，包含主机和模板，主机组通常在给用户或者是用户组指派监控权限时使用。</p><h3 id="3、监控项（item）"><a href="#3、监控项（item）" class="headerlink" title="3、监控项（item）"></a>3、监控项（item）</h3><p>一个特定监控指标的相关数据，比如内存的大小、CPU的使用率，甚至是服务的运行状态等等。监控项数据来源于被监控对象，并且每个监控项都由一个key来标识。</p><h3 id="4、触发器（trigger）"><a href="#4、触发器（trigger）" class="headerlink" title="4、触发器（trigger）"></a>4、触发器（trigger）</h3><p>一个表达式，用于评估监控项的值是否在合理的范围内。当接收的值超出触发器的规定时，就被认为是故障，如果超出后再次符合，就被认为是正常，也就意味着这是一个过程，it运维小分队里的告警机器人用的就是该项。</p><h3 id="5、事件（event）"><a href="#5、事件（event）" class="headerlink" title="5、事件（event）"></a>5、事件（event）</h3><p>触发器触发的一个特定事件，或者是zabbix定义的一个自动上线注册主机的事件。</p><h3 id="6、动作（action）"><a href="#6、动作（action）" class="headerlink" title="6、动作（action）"></a>6、动作（action）</h3><p>指根据配置，zabbix对于触发器触发的特定事件进行处理的具体措施，如执行某个脚本，或者是向管理员邮箱发送邮件等等。</p><h3 id="7、报警升级（escalation）"><a href="#7、报警升级（escalation）" class="headerlink" title="7、报警升级（escalation）"></a>7、报警升级（escalation）</h3><p>发送警报或者是执行远程命令的自定义方案。</p><h3 id="8、媒介（media）"><a href="#8、媒介（media）" class="headerlink" title="8、媒介（media）"></a>8、媒介（media）</h3><p>发送通知（告警）的手段，如微信、邮件、钉钉等等。</p><h3 id="9、通知（notification）"><a href="#9、通知（notification）" class="headerlink" title="9、通知（notification）"></a>9、通知（notification）</h3><p>通过指定的媒介，向用户发送的有关事件的信息。</p><h3 id="10、远程命令（remote-command）"><a href="#10、远程命令（remote-command）" class="headerlink" title="10、远程命令（remote command）"></a>10、远程命令（remote command）</h3><p>指运维人员提前写好的命令，可以让被监控主机在触发事件后执行。</p><h3 id="11、模板（template）"><a href="#11、模板（template）" class="headerlink" title="11、模板（template）"></a>11、模板（template）</h3><p>用于快速定义被监控主机的预设条目集合，通常包括了监控项、触发器、应用等，模板可以直接链接至某个主机。</p><h3 id="12、应用（application）"><a href="#12、应用（application）" class="headerlink" title="12、应用（application）"></a>12、应用（application）</h3><p>一组监控项的集合。</p><h3 id="13、web场景（web-scennario）"><a href="#13、web场景（web-scennario）" class="headerlink" title="13、web场景（web scennario）"></a>13、web场景（web scennario）</h3><p>用于检测web站点可用性的一个或多个HTTP请求。</p><h3 id="14、前端（frontend）"><a href="#14、前端（frontend）" class="headerlink" title="14、前端（frontend）"></a>14、前端（frontend）</h3><p>zabbix的web接口。</p><p>通过本次学习，对zabbix有了初步的了解。</p>]]></content>
    
    
    <categories>
      
      <category>网络运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>zabbix</tag>
      
      <tag>运维监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>winget工具概述</title>
    <link href="/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="WinGet概述"><a href="#WinGet概述" class="headerlink" title="WinGet概述"></a>WinGet概述</h1><p>以下资料来源于微软社区：<a href="https://learn.microsoft.com/zh-cn/windows/package-manager/">https://learn.microsoft.com/zh-cn/windows/package-manager/</a></p><h2 id="什么是WinGet？"><a href="#什么是WinGet？" class="headerlink" title="什么是WinGet？"></a>什么是WinGet？</h2><p>Windows软件包管理器 (WinGet) 是一个工具，帮助用户在Windows系统上发现和安装软件包。项目包括命令行界面 (CLI)、PowerShell模块和组件对象模型 (COM) API。客户端可以访问来自Microsoft Store和WinGet社区库的包,同时支持自建软件源访问。</p><h2 id="什么系统支持使用WinGet？"><a href="#什么系统支持使用WinGet？" class="headerlink" title="什么系统支持使用WinGet？"></a>什么系统支持使用WinGet？</h2><p>Windows 10（1809）以后的版本，会自动安装WinGet工具。在此之前的windows系统需要手动安装，在微软商店。<br>windows 10 （1709）以后都支持使用，但是有一个前提条件，必须更新微软商店，原因是windows11采取了新的微软商店并强制要求所有商店更新至该版本否则不能使用。由于是新系统下的商店，很多依赖项在win10上是没有的，需要手动去安装，具体参考文章windows 10下安装winget。<br>最低支持版本：<br>winget 命令行工具仅在 Windows 10 1709（版本 16299）或更高版本上受支持。 在你首次以用户身份登录 Windows（这会触发 Microsoft Store 将 Windows 程序包管理器注册为异步进程的一部分）之前，winget 工具不可用。 如果最近已经以用户身份进行了首次登录，但发现 winget 尚不可用，则可以打开 PowerShell 并输入以下命令来请求此 winget 注册：Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe。</p><h2 id="WinGet支持哪些安装程序？"><a href="#WinGet支持哪些安装程序？" class="headerlink" title="WinGet支持哪些安装程序？"></a>WinGet支持哪些安装程序？</h2><p>● EXE（具有 Silent 和 SilentWithProgress 标志）<br>● ZIP<br>● INNO<br>● NULLSOFT<br>● MSI<br>● WIX<br>● APPX<br>● MSIX<br>● BURN<br>● PORTABLE</p><h3 id="WinGet的下载"><a href="#WinGet的下载" class="headerlink" title="WinGet的下载"></a>WinGet的下载</h3><p>这里提供一个稳定版本1.8.1522<br>github地址:<a href="https://github.com/microsoft/winget-cli/releases">https://github.com/microsoft/winget-cli/releases</a></p><h2 id="WinGet应用场景"><a href="#WinGet应用场景" class="headerlink" title="WinGet应用场景"></a>WinGet应用场景</h2><p><img src="/img/winget_1.png" alt="winget_1"><br><img src="/img/winget_2.png" alt="winget_2"></p><p>通过以上方法，提升了网络整体安全性，避免了终端用户从不安全网站下载非法应用所带来的内网安全隐患。同时，通过使用批处理脚本实现批量安装应用程序，减少了重复工作，提高了工作效率。</p><h2 id="WinGet软件源的搭建"><a href="#WinGet软件源的搭建" class="headerlink" title="WinGet软件源的搭建"></a>WinGet软件源的搭建</h2><p>准备工作，创建软件清单<br>这里用wingetcreate来实现软件清单创建<br>通过winget命令install wingetcreate（建议连接vpn，这里可能因为网络因素安装失败）<br>寻找需要的软件包，获取其下载链接。<br>通过wingetcreate new install url，来获取清单。<br>可以通过 wingetcreate.exe update –urls 来更新清单。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a></p><h3 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h3><p>由于winget要求软件源必须使用HTTPS，所以需要通过nginx的反向代理来实现访问。<br>安装过程不在这里赘述，贴一张nginx配置文件提供参考。</p><h3 id="搭建Rewinged"><a href="#搭建Rewinged" class="headerlink" title="搭建Rewinged"></a>搭建Rewinged</h3><p>Rewinged 是一个自托管的 winget 包源工具，可以运行在 Linux、Windows、Docker 或云环境中。它通过读取目录中的包清单，并通过 REST API 使这些包可以被 winget 客户端搜索和访问。这使得用户可以创建和管理自己的私有 winget 包源，而无需依赖于云服务，winget 要求 REST 源使用 HTTPS - 不允许明文 HTTP。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a><br>封装好的程序包地址：<a href="https://github.com/jantari/rewinged/releases">https://github.com/jantari/rewinged/releases</a></p><ol><li>将wingetcreate创建的清单移至服务器，Rewinged 对应目录下（wingetcreate及winget仅可在Windows运行，若操作系统为其他则需要手动填写清单，或将wingetcreate创建的清单移到对应文件夹中）</li><li>通过参数configFile可以将所有参数写成一个json来执行</li><li>命令行执行，运行Rewinged并在后台运行，在rg目录下会有一个日志文件生成<br>nohup .&#x2F;rewinged -configFile &#x2F;rg&#x2F;rewinged.json<br>以下是一个基础的配置文件<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;autoInternalize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/installers&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizeSkip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;https&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsCertificateFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.crt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsPrivateKeyFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.key&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:3000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;logLevel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;info&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;manifestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/manifests&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>这里要讲一个参数的功能，-autoInternalize开启自动内化，启用后会将软件清单内的下载URL自动下载到本地指定文件夹，从而实现在不连接外网仅连接内网的情况下安装软件。第一次启用该功能会有一个下载软件的过程，在此过程中直接下载则会显示哈希认证不完整，必须等软件包被完整下载才可以正常使用。(从下载url到指定文件夹的这个过程可能会失败，每个软件都需要下载测试一下)<br>这里说一下如果安装包hash校验不通过或者下载不完整怎么处理。<br>首先下载一个完整的安装包，将exe后缀去除使其变为文件，随后打开cmd页面输入命令“winget hash 文件路径”生成文件的哈希值。<br>随后找到rewinged目录下，修改对应软件目录下的installer文件</li></ol><p>替换yaml文件内的哈希值为你下载的软件包哈希</p><p>随后到installers目录下，删除原先的软件包，将新下载的软件名称修改为哈希值（通过哈希值为索引），重启rewinged工具，完成替换。<br>扩展参数<br>这些命令行配置是用于配置和运行 <code>rewinged</code> 应用程序的参数。下面是每个参数的详细解释：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-autoInternalize<br><span class="hljs-bullet">   -</span> 作用：开启自动内部化功能。<br><span class="hljs-bullet">   -</span> 说明：启用此功能后，应用程序会自动将一些内容进行内部处理。<br><br>-autoInternalizePath string<br><span class="hljs-bullet">   -</span> 作用：指定自动内部化安装程序存储的目录。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./installers&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：自动内部化的安装程序将被存储在这个指定的目录中。<br><br>-autoInternalizeSkip string<br><span class="hljs-bullet">   -</span> 作用：指定排除在自动内部化之外的主机名列表。<br><span class="hljs-bullet">   -</span> 说明：可以用逗号或空格分隔多个主机名，这些主机将不进行自动内部化处理。<br><br>-configFile string<br><span class="hljs-bullet">   -</span> 作用：指定一个 JSON 配置文件的路径。<br><span class="hljs-bullet">   -</span> 说明：这个文件是可选的，可以用来提供额外的配置选项。<br><br>-https<br><span class="hljs-bullet">   -</span> 作用：直接从 <span class="hljs-code">`rewinged`</span> 应用程序提供加密的 HTTPS 流量，而无需代理。<br><span class="hljs-bullet">   -</span> 说明：启用此选项后，应用程序将使用 HTTPS 协议。<br><br>-httpsCertificateFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的 Web 服务器证书文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./cert.pem&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：这是应用程序在启用 HTTPS 时使用的证书文件路径。<br><br>-httpsPrivateKeyFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的私钥文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./private.key&quot;`</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**说明**</span>：这是应用程序在启用 HTTPS 时使用的私钥文件路径。<br><br>-listen string<br><span class="hljs-bullet">   -</span> 作用：指定 REST API 监听的地址和端口。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;localhost:8080&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：应用程序的 REST API 将在这个地址和端口上进行监听。<br><br>-logLevel string<br><span class="hljs-bullet">   -</span> 作用：设置日志的详细程度。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;info&quot;`</span><br><span class="hljs-bullet">   -</span> 可选值：<span class="hljs-code">`disable`</span>, <span class="hljs-code">`error`</span>, <span class="hljs-code">`warn`</span>, <span class="hljs-code">`info`</span>, <span class="hljs-code">`debug`</span>, <span class="hljs-code">`trace`</span><br><span class="hljs-bullet">   -</span> 说明：用于控制应用程序的日志输出详细程度。<br><br>-manifestPath string<br><span class="hljs-bullet">    -</span> 作用：指定搜索包清单文件的目录。<br><span class="hljs-bullet">    -</span> 默认值：<span class="hljs-code">`&quot;./packages&quot;`</span><br><span class="hljs-bullet">    -</span> 说明：应用程序将在这个目录中搜索包清单文件。<br><br>-version<br><span class="hljs-bullet">    -</span> 作用：打印版本信息并退出。<br><span class="hljs-bullet">    -</span> 说明：运行时不会启动应用程序，而是打印当前版本信息。<br></code></pre></td></tr></table></figure><h2 id="WinGet工具的使用"><a href="#WinGet工具的使用" class="headerlink" title="WinGet工具的使用"></a>WinGet工具的使用</h2><p>常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">● winget show 软件名  <span class="hljs-comment">#查询软件库中软件信息，该命令支持中文检索</span><br>● winget install --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#安装软件，通过查询软件名可知id号，通过id号来安装，避免因为软件名称混淆导致的安装失败（在WinGet自带的软件库中，就存在QQ、腾讯QQ，以及不同来源的QQ，直接使用软件名安装可能会导致安装失败）</span><br>● winget uninstall --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#卸载软件，使用id号原因同上</span><br>● winget upgrade --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#更新软件，从软件库中获取更新</span><br>● winget list  <span class="hljs-comment">#查询安装的应用程序</span><br></code></pre></td></tr></table></figure><p>已管理员的身份启动命令行，执行“ winget source add -n qunhe -a <a href="https://winget.qunhequnhe.com/api">https://winget.qunhequnhe.com/api</a> -t “Microsoft.Rest”，随后“winget install 软件名 -s qunhe”即可。<br>这里我写一个bat脚本，能够自动执行添加软件源及安装小酷助手、企业微信、WPS及腾讯会议。有特殊需求直接修改这个脚本即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@echo off<br>echo Installing standard software...<br>winget <span class="hljs-selector-tag">source</span> add -n qunhe -<span class="hljs-selector-tag">a</span> https:<span class="hljs-comment">//winget.qunhequnhe.com/api -t &quot;Microsoft.Rest&quot;</span><br>winget install qunhe<span class="hljs-selector-class">.xiaoku</span> qunhe<span class="hljs-selector-class">.qiyeweixin</span>  KingsoftCorp<span class="hljs-selector-class">.Ltd</span><span class="hljs-selector-class">.WPSOffice</span> Tencent<span class="hljs-selector-class">.WeMeet</span> -s qunhe<br>echo Installation complete.<br></code></pre></td></tr></table></figure><p>功能测试：<br><img src="/img/winget_3.png" alt="winget_3"><br>需要注意以下几点，</p><ol><li>win系统必须带有winget</li><li>必须能解析winget.qunhequnhe.com这个域名如果不可以可能是你的dns服务器设置的有问题，可以尝试使用10.1.102.201<br>拓展参数：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">install</span>    安装给定的程序包<br>  show       显示包的相关信息<br>  source     管理程序包的来源<br>  search     查找并显示程序包的基本信息<br>  list       显示已安装的程序包<br>  upgrade    显示并执行可用升级<br>  uninstall  卸载给定的程序包<br>  hash       哈希安装程序的帮助程序<br>  validate   验证清单文件<br>  settings   打开设置或设置管理员设置<br>  features   显示实验性功能的状态<br>  ex<span class="hljs-keyword">port</span>     导出已安装程序包的列表<br>  <span class="hljs-keyword">import</span>     安装文件中的所有程序包<br>  pin        管理包钉<br>  configure  将系统配置为所需状态<br>  download   从给定的程序包下载安装程序<br>  repair     修复所选包<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>IT技术支持</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>winget</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
