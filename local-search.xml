<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SRE-Google运维解密-第五章减少琐事</title>
    <link href="/2024/08/28/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%87%8F%E5%B0%91%E7%90%90%E4%BA%8B/"/>
    <url>/2024/08/28/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%87%8F%E5%B0%91%E7%90%90%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章更像阐述一种世俗的道理而非技术理论，本篇的思想可以应用在生活中的各个方面。<br><strong>“如果系统正常运转中需要人工干预，应该将此视为一种Bug。”</strong></p><h2 id="琐事的定义"><a href="#琐事的定义" class="headerlink" title="琐事的定义"></a>琐事的定义</h2><p>书中指出，琐事不仅仅代表“我不喜欢做的工作”，在工程任务中或多或少，每个人都会遇到琐事，每个人满意和喜欢的工作内容也是不同的。同时，如管理类的琐事是必须的，这一类被归纳到流程开销中。流程开销通常指与运维工作不直接相关的工作，比如团队会议、目标的建立与评估、日报周报月报等。还有一些是脏活累活，这些脏活累活通常具有长期价值，这些事物也不能算作琐事，比如调整过高的告警，这可能是一件重复性高且繁重的任务，但这不是琐事。<br><strong>那到底什么是琐事？书中指出琐事就是运维服务中手动性的，重复性的，可以被自动化，战术性，没有持久价值的工作。</strong>而且琐事与服务呈线性关系的增长，并不是每件琐事都有以上的全部特性，每件琐事都满意下列一个或多个属性。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="手动性"><a href="#手动性" class="headerlink" title="手动性"></a>手动性</h4><p>例如手动的运行脚本来执行任务，虽然运行一个脚本比手动一步步执行要快，但具体运行脚本所花费的手动时间（不是脚本的运行时间）应该被认为琐事。这里我的理解是自动化运行，定时定期，或者触发性的来运行，比如释放内存。</p><h4 id="重复性"><a href="#重复性" class="headerlink" title="重复性"></a>重复性</h4><p>一件事如果重复做不超过三次，这不能被算作一件琐事。琐事对于重复性的定义是不停反复做的工作，就像打螺丝。如果你是为了解决一个问题而反复进行某场实验，这不能算作琐事。</p><h4 id="可以被自动化的"><a href="#可以被自动化的" class="headerlink" title="可以被自动化的"></a>可以被自动化的</h4><p>如果一件事，计算机可以和人类一样甚至超出人类水平地来完成某个任务，或者通过某种设计变更来彻底消除对某项任务的需求，那么这项任务就是琐事，工作中有非常多这样的琐事，<strong>比如不用DHCP</strong>。如果该项任务的主观判断是必须，那么很大程度上来说，这项任务不属于琐事。（比如流量控制，对于更需要流量的用户分配更高的流量阈值是合理的，但是给领导设置更高的流量阈值嘛，机器是不懂人情世故的。）</p><h4 id="战术性的"><a href="#战术性的" class="headerlink" title="战术性的"></a>战术性的</h4><p>突然的、应对式的工作属于琐事，驱动它们的并非策略或主动安排。处理警报就是琐事，这是无法被避免的工作，但我们必须努力去减少它。</p><h4 id="没有持久价值的"><a href="#没有持久价值的" class="headerlink" title="没有持久价值的"></a>没有持久价值的</h4><p>在完成某一项任务后，服务的状态没有改变，那这就是一件琐事。如果你完成某一项任务，服务得到了改进，它就不是琐事。</p><h4 id="与服务同步线性增长"><a href="#与服务同步线性增长" class="headerlink" title="与服务同步线性增长"></a>与服务同步线性增长</h4><p>书中指出在工作中所设计的任务与服务的大小、流量或用户数量呈线性增长关系，那这项任务可能属于琐事。一个良好管理和设计的服务应该至少可以应对一个数量级的增长，而不需要某些一次性工作（例如增加资源）之外的额外工作。</p><h2 id="为什么琐事越少越好？"><a href="#为什么琐事越少越好？" class="headerlink" title="为什么琐事越少越好？"></a>为什么琐事越少越好？</h2><p>如果琐事不加以控制，它会变得越来越多，以至于迅速占据我们每个人100%的时间。书中指出一个合格的SRE工程师，琐事所占据的工作时间应不超过50%。<br>根据统计，琐事最大的来源是中断性工作（即与服务相关的非紧急的邮件和电子邮件），另一个来源则是on-call（紧急的，值班），紧随其后的是发布和数据更新。<br>在Google SRE工程师中，琐事占用的时间大约在33%。</p><h2 id="什么算作工程工作"><a href="#什么算作工程工作" class="headerlink" title="什么算作工程工作"></a>什么算作工程工作</h2><p>工程工作是一种新颖的、本质上需要主观判断的工作。其符合长期战略，会对你的服务进行长久性的改善的工作。通常具有创新性和创造性，着重通过设计来解决问题，解决方案越通用越好。其有助于运维团队在维持同等人员配置的情况下接受更大或更多的服务。</p><h3 id="常见的工程工作"><a href="#常见的工程工作" class="headerlink" title="常见的工程工作"></a>常见的工程工作</h3><h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><p>编写或修改代码，及其相关设计和文档工作。例：自动化编写脚本，创造工具或框架，增加可扩展性和可靠性的服务功能，或修改基础设施代码以使其更稳健。</p><h4 id="系统工程"><a href="#系统工程" class="headerlink" title="系统工程"></a>系统工程</h4><p>配置生产系统、修改现存配置，或者用一种通过一次性工作产生持久的改进的方法来书写系统文档。例：监控的部署和更新、负载均衡的配置、服务器配置、操作系统的参数调整和负载均衡器的部署。系统工程还包括与研发团队进行的架构、设计和生产环境方面的咨询工作。</p><h4 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h4><p>与运维服务相关的重复性的、手工的劳动。</p><h4 id="流程负担"><a href="#流程负担" class="headerlink" title="流程负担"></a>流程负担</h4><p>与运维服务不直接相关的行政工作。例如招聘、人力资源书面工作、团队&#x2F;公司会议、任务系统的定期清理工作、工作总结、同行评价和自我评价，以及培训课程等。</p><h2 id="琐事繁多是不是一定不好"><a href="#琐事繁多是不是一定不好" class="headerlink" title="琐事繁多是不是一定不好"></a>琐事繁多是不是一定不好</h2><p>琐事虽然会让人不开心，但也不会一直让其不开心，特别是其不太多的情况下。已知和重复的工作让人有一种平静的功效，完成这些事可以带来一种满足和快速胜利感（俗称“割草无双”）。琐事可能是低风险和低压力的活动，有些员工更喜欢做这种事。<br>虽然琐事的存在并不总是坏事，但是它还是会带来如下影响</p><h3 id="职业停滞"><a href="#职业停滞" class="headerlink" title="职业停滞"></a>职业停滞</h3><p>经常做低风险和低压力的活动，甚至是脏活累活，这样并不能得到成长，没有人可以通过不停地做脏活累活满足自己的职业发展。</p><h3 id="士气低落"><a href="#士气低落" class="headerlink" title="士气低落"></a>士气低落</h3><p>每个人对自己可以承担的琐事限度有所不同，但是一定有个限度。过多的琐事会导致过度劳累、厌倦和不满。</p><h3 id="造成误解"><a href="#造成误解" class="headerlink" title="造成误解"></a>造成误解</h3><p>如果个人或者团队过度参与琐事，会破坏这种角色，造成误解。（感觉自己不是运维工程师~）</p><h3 id="进展缓慢"><a href="#进展缓慢" class="headerlink" title="进展缓慢"></a>进展缓慢</h3><p>每个人对自己可以承担的琐事限度有所不同，但是一定有个限度。过多的琐事会导致过度劳累、厌倦和不满。</p><h3 id="开创先例"><a href="#开创先例" class="headerlink" title="开创先例"></a>开创先例</h3><p>如果SRE过于愿意承担琐事，研发同事就更倾向于加入更多的琐事，有时候甚至将本来应该由研发团队承担的运维工作转给SRE来承担。</p><h3 id="促进摩擦产生"><a href="#促进摩擦产生" class="headerlink" title="促进摩擦产生"></a>促进摩擦产生</h3><p>即使你个人对琐事没有怨言，你现在的或未来的队友可能会很不开心。如果团队中引入了太多的琐事，其实就是在鼓励团队里最好的工程师开始寻找其他地方提供的更有价值的工作。</p><h3 id="违反承诺"><a href="#违反承诺" class="headerlink" title="违反承诺"></a>违反承诺</h3><p>那些为了项目工程工作而新入职的员工，以及转入SRE的老员工会有被欺骗的感觉，这非常不利于公司的士气。（感觉自己不是运维工程师~）</p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE:Google运维解密_第四章服务质量目标</title>
    <link href="/2024/08/16/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87/"/>
    <url>/2024/08/16/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对SRE感兴趣是因为我的实习工作，工作中内部文档给我所带来的技术视野提升让我意识到不能止步于传统的网络技术，技术跟随时代一起前进，我也不能被落下。</p><h2 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h2><p>这里就不讲SRE的概念了，感兴趣的可以自己去搜集资料，SRE是devops这个概念的前身。</p><h2 id="为什么选择这本书？"><a href="#为什么选择这本书？" class="headerlink" title="为什么选择这本书？"></a>为什么选择这本书？</h2><p>Google作为一家为全球提供网络服务的公司，其网络所承载的数据量极大，在技术领域一直处在世界领先位置，跟着领头羊走准没错。不过该书中一些产品及技术均为谷歌自研，参考意义不大，更多的是学习其思路和扩展技术视野。</p><h2 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h2><p>这个概念在系统中非常重要，没有服务质量，不去度量这些行为的正确性，就无法正确的运维一个系统。<br>书中提到了三个有关服务质量的概念，分别是服务质量指标（SLI）、服务质量目标（SLO）以及服务质量协议（SLA）。<br><strong>这三项指标分别是指向服务或系统内最为重要的基础指标、指标的预期值以及当不满足预期时的应对计划。</strong><br>事先确定合适的指标有助于运维发现风险、解决风险。</p><h3 id="服务质量术语"><a href="#服务质量术语" class="headerlink" title="服务质量术语"></a>服务质量术语</h3><p>SLA、SLI、SLO这三者概念其实我都不是很清楚，正好借此机会好好梳理一番。</p><h4 id="服务质量指标SLI"><a href="#服务质量指标SLI" class="headerlink" title="服务质量指标SLI"></a>服务质量指标SLI</h4><p>SLI是指某一服务的某项服务质量下一个具体量化指标<br>举一个例子，比如响应时间，99%的用户请求在200ms内响应。<br>书中提出SLI一般都是通过汇总：在某一个度量时间范围内将原始数据收集起来，计算速率、平均值、百分比等汇总数据。<br>书中指出在理想状态下，SLI应该直接度量某一个具体的服务质量。当然，这是不可能的，不然就没有另外两个指标概念了。<br><strong>在很多情况下，直接的度量信息可能非常难以获取，或者无法被观测，只能抽象的使用某种指标替代。</strong><br>这里举一个书中的例子，比如客户端的延迟通常是最直接的用户指标，但是由于条件限制或其他因素，只能监控服务端的延迟数据。</p><p>另一个被重视的SLI指标是可用性，其代表了服务可用时间的百分比，该指标通常利用“格式正确的请求成功处理的比例”来定义。也会被成为服务产出。<br>在存储系统中，持久性也是一个重要的SLI指标，持久性是指一组数据能够完整保存的时间。100%的“可用性”、“持久性”是不可能实现的，只能以接近100%的指标作为一个未来实现的目标，行业内也经常用9的数量来描述可用程序，目前Google云计算服务公开的可用性指标是“3.5个9”–99.95%可用。</p><h4 id="服务质量目标SLO"><a href="#服务质量目标SLO" class="headerlink" title="服务质量目标SLO"></a>服务质量目标SLO</h4><p>SLO是指服务某个SLI的目标值，或者目标范围。<br>SLO的定义是SLI&lt;&#x3D;目标值，或者范围下限&lt;&#x3D;SLI&lt;&#x3D;范围上限。<br>比如你打游戏，游戏的延迟就不能太高，不然就会很卡。对游戏延迟的这个预期就是一种SLO。<br>本书中提到了莎士比亚搜索服务，并以此举例，感兴趣的可以去原书阅读。<br>书中指出选择一个合适的SLO是非常复杂的过程，影响其的因素众多，比如无法确定一个具体的值，书中提出了一个例子，比如外部传入的HTTP请求，其每秒查询数量（QPS）指标是由用户决定的，用户可以刷新或多次查询，这样会导致一个用户传出多个请求，从而无法正确的设置一个SLO。<br>书中也指出，虽然无法这样确定一个SLO，但可以通过其他的角度来看待，比如通过指定平均请求的延迟。<br>这两个SLI，QPS和延迟两者是很可能相关联的：QPS的升高通常会导致延迟升高，服务到达一定负载水平后性能下降是常见的。</p><p>通过设立SLO，可以帮助设立用户对服务质量的预期，避免用户抱怨“服务太慢了”。如果没有该指标，用户就会按照自己的想法设置一个SLO，这个SLO不一定具有合理性，导致其错误的认为这个更可靠或更不可靠。</p><p>阅读到这里，书中给出了一个真实的例子，全球Chubby服务计划内停机，具体细节请自行查阅。大致内容是Chubby是一个被众多系统所依赖的服务，其有一个预期的SLO，如果该季度没有达到，Google的SRE工程师通过计划内停止提供该服务来使系统不那么依赖该服务，对其可靠性有更明确的认知。</p><h4 id="服务质量协议SLA"><a href="#服务质量协议SLA" class="headerlink" title="服务质量协议SLA"></a>服务质量协议SLA</h4><p>SLA指服务与用户之间一个明确的，或者不明确的协议，讲述了在达到或者没有达到SLO之后的后果。这些后果可以是财务方面的，也可能是其他类型的，具体由服务和用户之间协定。<br>看起来SLA和SLO有些类似，怎么区别它们呢？<br>“如果SLO没有打到时，有什么后果”如果没有明确的后果，那么就是一个SLO，而非SLA。</p><p>通常来说，SRE工程师不会参与到SLA的书写，因为SLA是与业务产品决策息息相关的，SRE工程师通常是作为辅助为参与者提供帮助，避免触发SLA中的惩罚性条款，同时参与定义具体的SLI。</p><p>举一个例子，比如Google的搜索服务是否可用或Google的工作流系列软件，不管某个服务是否具有SLA，定义SLI与SLO，并且用它们来管理服务质量都是很有价值的。</p><h2 id="指标在实践中的应用"><a href="#指标在实践中的应用" class="headerlink" title="指标在实践中的应用"></a>指标在实践中的应用</h2><p>在前面，我们讲述了有关服务质量的一些概念，讲述了为什么合适的指标对于服务质量来说这么重要，接下来是如何判断哪些指标对服务是最重要的。</p><h3 id="运维人员和最终用户各关心什么？"><a href="#运维人员和最终用户各关心什么？" class="headerlink" title="运维人员和最终用户各关心什么？"></a>运维人员和最终用户各关心什么？</h3><p>首先，不是监控系统中的所有数据都可以被定义为SLI；只有理解用户对系统的真实需求，才能决定哪些数据是否有用。过多的设立指标会减少那些对系统真正重要的指标的关注，过少的指标则会导致某些重要的系统行为被忽略。书中建议，四到五个具有代表性的指标对系统监控程序的评估和关注就足够了。<br>书中将常见的SLI分为以下几大类：<br>用户可见的系统服务：通常是可用性、延迟以及吞吐量，换种说法，是否能正常处理请求？每个请求花费的时间是多少？多少的请求可以被处理？<br>存储系统的通常强调：通常是延迟、可用性以及持久性。读写数据需要的时间，是否可以随时访问数据，数据经过一段时间是否能被正常的读取。<br>大数据系统：这类系统通常是数据处理流水线系统，通常关注吞吐量和端到端的延迟。处理了多少数据？数据从输入到产出需要多少时间？<br>系统正确性：这是所有系统都应该关注的，只有返回一个正确的回复，正确的过程，这才是一个正确的系统。正确性是衡量系统健康程度的一个重要指标，但是其更关注系统内部的数据，而不是系统本身，通常这不是SRE直接负责的。</p><h3 id="如何收集指标"><a href="#如何收集指标" class="headerlink" title="如何收集指标"></a>如何收集指标</h3><p>利用某种监控系统，比如zabbix、Prometheus，大部分的指标数据都在服务器端被收集。也可以利用一些日志分析系统，分析日志中某种状态码回复所占的比例。当然，也有一些系统可以加入到客户端数据的收集，可以收集到一些不影响服务器端，但是能对用户产生影响的问题。<br>书中还是拿莎士比亚搜索系统举例，过于关注莎士比亚服务器搜索后端延迟可能会导致错失页面JS脚本导致的用户可见的延迟问题，在这个例子中，度量页面在浏览器中可用的延迟是度量用户体验的一个更好的指标。</p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>监控数据通常是庞大的，我们需要通过一些手段来简化使数据可用，汇总是手段的一种，汇总的过程应该非常小心。<br>对待一些简单的指标也不要掉以轻心，大部分指标都应该以“分布”，而不是平均值来定义。<br>响应时间的分布的分散程度与用户受到长尾请求延迟的影响关联性较高，这可能预示了负载过高情况下出现的排队问题。<br>书中指出，经研究显示，用户更喜欢速度较慢但是更稳定的系统，而不是一个请求速度抖动很厉害的系统。<br>经过上述结论，某些SRE团队只关注长尾部分，因为如果99.9%的系统行为都正常的话，那50%部分就肯定也是正常的。<br><strong>注：长尾部分在监控数据中代表了异常值或极端值，这些数据点虽然数量较少，但往往具有重要的意义。通过识别和分析长尾部分，可以发现并解决潜在的问题，从而提高系统的稳定性和用户体验。</strong><br>书中还讨论了为什么采取分布式而不是平均值的方式，这里不过多赘述，感兴趣可以自行阅读。</p><h3 id="指标的标准化"><a href="#指标的标准化" class="headerlink" title="指标的标准化"></a>指标的标准化</h3><p>书中提到指标的标准化，通过制作标准化模板来避免重复的操作，减轻工作量。</p><h2 id="目标在实践中的应用"><a href="#目标在实践中的应用" class="headerlink" title="目标在实践中的应用"></a>目标在实践中的应用</h2><p>书中指出，度量用户真正关心的部分是非常难，甚至不可实现的。所以需要通过某种近似的方法，与其选择指标，再想出对应的目标，不如从想要的目标反向推导出具体的指标。</p><h3 id="目标的定义"><a href="#目标的定义" class="headerlink" title="目标的定义"></a>目标的定义</h3><p>为了更清晰地定义，SLO应该具体指出它们是如何被度量的，以及其有效条件。<br>如果某个SLI很重要，也可以指定多个SLO目标。<br>要求SLO能够被100%满足是不正确，也是不显示的，过于强调则会降低创新和部署的速度，增加成本，损失创造性。<br>书中给出了一个更好的办法，使用错误预算（Error Budget）。对达不到SLO的容忍度，以时间单位计量对其评估，概括一下就是SLO的SLO。<br>通过周期性的监控SLO达标程度可以展示一个趋势，这样就可以在重大问题发生之前得到预警。<br>书中指出SLO不达标的频率可以用来与错误预算进行对比，利用这两个数值的差值可以指导新版本的发布。</p><h3 id="目标的选择"><a href="#目标的选择" class="headerlink" title="目标的选择"></a>目标的选择</h3><p>设置SLO不是一个单纯的技术活动，设计到产品和业务层面的决策。有些时候需要考虑到各个方面，做出一些放弃的决策。<br>书中给出了一些建议<br><strong>不要仅以目前的状态为基础选择目标</strong><br>要从全局考虑，避免团队被迫长期运维一个过时的系统。<br><strong>保持简单</strong><br>复杂的系统往往会掩盖系统的一些变化，同时也更难以理解。<br><strong>避免绝对值</strong><br>绝对值在系统设计中是不切实际的，即使有一种系统能达到这种要求，所付出的代价也是不可估量的，也比用户所需的高出许多。<br><strong>SLO越少越好</strong><br>SLO必须精准，尽量精简，抛弃不必要的SLO。<br><strong>不要追求完美</strong><br>追求完美往往会陷入一个不可走出的怪圈，可以从一个松散的目标开始，再逐步优化缩紧，这比一开始制定一个困难的计划，并执行容易的多。<br>好的SLO对团队有益，但是一个没有精心调校的SLO会导致浪费。</p><h2 id="控制手段"><a href="#控制手段" class="headerlink" title="控制手段"></a>控制手段</h2><p>通过SLI和SLO在决策系统运维时非常有用<br>举例，某个系统服务在一个时间段内延迟持续上涨，通过SLI及SLO判断，进行操作，解决风险。</p><h3 id="SLO建立用户预期"><a href="#SLO建立用户预期" class="headerlink" title="SLO建立用户预期"></a>SLO建立用户预期</h3><p>通过公布SLO可以使用户得到对系统行为的预期，以理解该服务是否能够满足他们的要求。<br>为了让用户拥有一个正确的预期，书中提出可以考虑以下几种策略：<br><strong>留出一定安全空间</strong><br>留出冗余，响应并解决问题。<br><strong>实际SLO也不要过高</strong><br>避免用户因冗余产生依赖，参考前面Chubby服务。</p><h2 id="协议在实践中的应用"><a href="#协议在实践中的应用" class="headerlink" title="协议在实践中的应用"></a>协议在实践中的应用</h2><p>起草一份SLA通常是业务部门和法务部门共同努力的结果，SRE在这之中作为以一个辅助者的角色来工作。帮助这些部门理解SLA的SLO达标率和困难程度。</p><p><strong>本章完</strong></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_3</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/</url>
    
    <content type="html"><![CDATA[<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><p>镜像是Docker的三大组件之一。<br><strong>运行容器前需要本地存在对应的镜像，如果本地不存在，则会从镜像仓库拉取镜像。</strong></p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"># 从Docker镜像仓库获取镜像<br>$ docker pull <span class="hljs-comment">[选项]</span> <span class="hljs-comment">[Docker Registry 地址<span class="hljs-comment">[:端口号]</span>/]</span>仓库名<span class="hljs-comment">[:标签]</span><br></code></pre></td></tr></table></figure><p>可能会出现的问题：命令仅支持小写<br>当前用户没有权限访问Docker守护进程<br>使用sudo提升权限，或者将用户加入Docker用户组</p><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看本地镜像</span><br>docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><strong>这个列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。</strong><br>前面提到过仓库和标签的概念，这里需要讲一下镜像ID的概念，就好比身份证这是唯一标识，一个镜像是可以对应多个标签。</p><p>当你查看本地镜像，你肯定会为其的体积之小感到惊讶。对比完整镜像系统动辄数G的大小，几十M的镜像文件有些不可思议。首先Docker上的镜像本身就是极简版，同时因为复用机制的存在，所以能如此高效。<br>真的是极简，vi都没有。<br>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 63.3MB，但是在 Docker Hub 显示的却是 25.47 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。<br>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。<br>你可以通过 docker system df 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:20.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 执行运行容器命令</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--rm ubuntu:20.04 bash</span><br></code></pre></td></tr></table></figure><p>这里讲一下各参数<br>-i： 使容器保持标准输入处于打开状态，即使没有连接终端。<br>-t： 分配一个伪TTY（终端），让你可以与容器进行交互。<br>–rm： 在容器退出时自动删除容器。这个选项确保容器在使用完毕后不会留在系统中，占用存储空间。  默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动docker rm。<br>ubuntu:20.04: 这是要使用的镜像和标签，表示基于ubuntu:20.04镜像创建容器。<br>bash: 这是在容器中要运行的命令。在这里，指定了bash，表示启动容器后，运行bash命令，使你进入容器的交互式终端。  </p><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p><strong>在镜像中，有一个特殊的镜像，其没有仓库名，也没有标签，均为none。</strong><br>这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 none。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 none 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#查找虚悬镜像</span><br>$ docker image ls -f <span class="hljs-attr">dangling=</span><span class="hljs-literal">true</span><br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br><span class="hljs-tag">&lt;none&gt;</span>              <span class="hljs-tag">&lt;none&gt;</span>              <span class="hljs-number">00285</span>df0df87        <span class="hljs-number">5</span> days ago          <span class="hljs-number">342</span> MB<br></code></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment">#删除悬空镜像</span><br><span class="hljs-variable">$ </span>docker image prune<br></code></pre></td></tr></table></figure><h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了<strong>加速镜像构建、重复利用资源</strong>，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#查看所有镜像，添加参数-a</span><br><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><p>不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。<br>根据仓库名列出镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#指定仓库名，查询仓库下的所有tag</span><br>$ docker image ls ubuntu<br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>ubuntu              <span class="hljs-number">18.04</span>               <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br>ubuntu              bionic              <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br></code></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#指定仓库名和标签，查询某个镜像</span><br>$ docker image ls ubuntu:<span class="hljs-number">18.04</span><br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>ubuntu              <span class="hljs-number">18.04</span>               <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br></code></pre></td></tr></table></figure><p>除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#通过过滤器参数查找指定镜像</span><br>$ docker image ls -f since=mongo:3.2<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>redis               latest              5f515359c7f8       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 183 </span>MB<br>nginx               latest              05a60462f8ba       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 181 </span>MB<br></code></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。<br>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#举例</span><br><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-operator">-f</span> label=com.example.version=<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2><p><strong>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。</strong>比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ docker image ls -q<br><span class="hljs-number">5</span>f5<span class="hljs-number">15359c7f8</span><br><span class="hljs-number">05</span>a60462f8ba<br>fe<span class="hljs-number">9198c04d62</span><br><span class="hljs-number">00285d</span>f0df87<br><span class="hljs-number">329</span>ed<span class="hljs-number">837d508</span><br><span class="hljs-number">329</span>ed<span class="hljs-number">837d508</span><br></code></pre></td></tr></table></figure><p>–filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。<br>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。<br>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">ls</span> <span class="hljs-string">--format</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123;.ID&#125;&#125;</span>: <span class="hljs-template-variable">&#123;&#123;.Repository&#125;&#125;</span>&quot;</span><br><span class="hljs-attr">5f515359c7f8:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">05a60462f8ba:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">fe9198c04d62:</span> <span class="hljs-string">mongo</span><br><span class="hljs-attr">00285df0df87:</span> <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span><br><span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span><br></code></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker image ls --format &quot;table </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ID</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Repository</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Tag</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br><span class="language-xml">IMAGE ID            REPOSITORY          TAG</span><br><span class="language-xml">5f515359c7f8        redis               latest</span><br><span class="language-xml">05a60462f8ba        nginx               latest</span><br><span class="language-xml">fe9198c04d62        mongo               3.2</span><br><span class="language-xml">00285df0df87        <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span></span><br><span class="language-xml">329ed837d508        ubuntu              18.04</span><br><span class="language-xml">329ed837d508        ubuntu              bionic</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_2_补充</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2-%E8%A1%A5%E5%85%85/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2-%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="配置Docker镜像源加速"><a href="#配置Docker镜像源加速" class="headerlink" title="配置Docker镜像源加速"></a>配置Docker镜像源加速</h1><p>因为不可抗因素，在国内Docker从仓库上pull镜像下来比较麻烦。<br>这里提供一个解决该问题的方法，配置镜像源加速。</p><p>可用系统：Ubuntu、Debian、CentOS<br>目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。</p><p>请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\-\-registry\-mirror&#x27;</span><br></code></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 $ systemctl cat docker 查看 ExecStart&#x3D; 出现的位置，修改对应的文件内容去掉 –registry-mirror 参数及其值，并按接下来的步骤进行配置。<br>如果以上命令没有任何输出，那么就可以在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>阿里镜像加速器<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?spm=a2c6h.12873639.article-detail.16.21cc12deEEPYCT">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?spm=a2c6h.12873639.article-detail.16.21cc12deEEPYCT</a></p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_2</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>系统：Ubuntu 22.04 LTS </p><h3 id="确保下载源安全性："><a href="#确保下载源安全性：" class="headerlink" title="确保下载源安全性："></a>确保下载源安全性：</h3><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># 添加使用HTTPS传输的软件包以及CA证书</span><br>$ sudo apt-get update<br><br>$ sudo apt-get install <span class="hljs-string">\</span><br>    apt-transport-https <span class="hljs-string">\</span><br>    ca-certificates <span class="hljs-string">\</span><br>    curl <span class="hljs-string">\</span><br>    gnupg <span class="hljs-string">\</span><br>    lsb-release<br></code></pre></td></tr></table></figure><h3 id="鉴于国内网络问题，修改为镜像源为国内源："><a href="#鉴于国内网络问题，修改为镜像源为国内源：" class="headerlink" title="鉴于国内网络问题，修改为镜像源为国内源："></a>鉴于国内网络问题，修改为镜像源为国内源：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 添加阿里源及软件源的GPG密钥</span><br>$ curl -fsSL https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/ubuntu/g</span>pg | sudo gpg --dearmor -o <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/keyrings/</span>docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">向 sources.list 中添加 Docker 软件源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure><h3 id="更新apt软件包缓存："><a href="#更新apt软件包缓存：" class="headerlink" title="更新apt软件包缓存："></a>更新apt软件包缓存：</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h3 id="安装Docker-ce："><a href="#安装Docker-ce：" class="headerlink" title="安装Docker-ce："></a>安装Docker-ce：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sudo apt-<span class="hljs-built_in">get</span> install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><h3 id="启动Docker："><a href="#启动Docker：" class="headerlink" title="启动Docker："></a>启动Docker：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl start docker</span><br></code></pre></td></tr></table></figure><h3 id="建立Docker用户组："><a href="#建立Docker用户组：" class="headerlink" title="建立Docker用户组："></a>建立Docker用户组：</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><h3 id="建立-docker-组："><a href="#建立-docker-组：" class="headerlink" title="建立 docker 组："></a>建立 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> groupadd docker</span><br></code></pre></td></tr></table></figure><h3 id="将当前用户加入-docker-组："><a href="#将当前用户加入-docker-组：" class="headerlink" title="将当前用户加入 docker 组："></a>将当前用户加入 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ docker run <span class="hljs-comment">--rm hello-world</span><br><br>Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling <span class="hljs-built_in">from</span> library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:<span class="hljs-number">308866</span>a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello <span class="hljs-built_in">from</span> Docker!<br>This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.<br><br>To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:<br> <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.<br> <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">&quot;hello-world&quot;</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.<br>    (amd64)<br> <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span><br>    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.<br> <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span><br>    <span class="hljs-built_in">to</span> your terminal.<br><br>To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:<br> $ docker run -<span class="hljs-keyword">it</span> ubuntu bash<br><br>Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:<br> <span class="hljs-keyword">https</span>://hub.docker.com/<br><br>For more examples <span class="hljs-keyword">and</span> ideas, visit:<br> <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_1</title>
    <link href="/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）:"></a>镜像（image）:</h3><p>众所周知，操作系统分为内核和用户空间（linux系统一切皆文件）。内核启动后，会挂载root文件系统为其提供用户空间支持。Docker的镜像，就相当于是一个root文件系统。<br>分层存储的概念：<br>镜像本身包含完整的root文件，体积往往是庞大的。Docker为了解决这种问题，在设计时充分利用Union Fs技术，将其设计为分层存储的架构。（ 因为多个镜像可以共享相同的基础层。例如，如果你有多个基于同一操作系统的镜像，这些镜像就可以共享这个操作系统层。）<br>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<br>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h4 id="简单比喻"><a href="#简单比喻" class="headerlink" title="简单比喻"></a>简单比喻</h4><p>可以把 Docker 镜像想象成一本书：<br>● 基础镜像 是书的第一个版本，只读的。<br>● 应用层 是你在第一个版本上增加的注释，还是只读的。<br>● 配置层 是你在前面的基础上又增加的更多注释，仍然只读。<br>● 容器 是你从这本书的最后一个版本上复印了一份，你可以在上面随便写东西（可写层）。<br>这个过程节省了很多纸张（空间），因为你的注释（修改）只是增加了几页，而不是重新写了一本书。</p><h2 id="容器（container）："><a href="#容器（container）：" class="headerlink" title="容器（container）："></a>容器（container）：</h2><p>镜像和容器之间的关系，就像面向对象中的类和实例一样。（类是一种模板，定义了对象属性和行为，它不真实存在。实例是根据类创建的具体对象，它具备类的属性和行为，并且真实存在。）<br>打个比方，车是一个类，具体到实例就是什么车，什么颜色，什么发动机等。<br>容器的实质是进程，但与在宿主机直接执行的进程不同，容器的进程有自己独立的命名空间。正因如此，容器可以拥有自己的root文件系统，各项配置都是独立的。容器内的进程是运行在一个隔离的环境里，使用起来就像一个独立的操作系统一样。这种特性借鉴了沙箱，也使得容器封装的应用比直接运行在宿主机更加安全。</p><p>容器与虚拟机之间的区别，虚拟机是一个完整的操作系统，而容器只是一个运行在宿主机上，拥有独立命令空间的进程。<br>● 虚拟机：提供完整的操作系统环境，资源开销大，启动慢，但隔离性强，适用于需要高度隔离和安全的场景。<br>● 容器：共享操作系统内核，资源开销小，启动快，但隔离性相对较弱，适用于轻量级、快速部署和需要高密度计算的场景。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id="Docker中的镜像和容器"><a href="#Docker中的镜像和容器" class="headerlink" title="Docker中的镜像和容器"></a>Docker中的镜像和容器</h3><p>● 镜像（Image）：镜像就像类，是一个模板，定义了应用程序及其运行环境的所有内容。它是一个只读的文件系统层，用于创建容器。<br>● 容器（Container）：容器就像实例，是镜像的一个具体实现。它是一个运行时的实例，具有镜像的所有特性，并且可以进行实际操作和修改。</p><h2 id="仓库（repository）："><a href="#仓库（repository）：" class="headerlink" title="仓库（repository）："></a>仓库（repository）：</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><h3 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h3><p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder&#x2F;nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-服务："><a href="#Docker-Registry-服务：" class="headerlink" title="Docker Registry 服务："></a>Docker Registry 服务：</h3><p>公有：<br>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。<br>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。除此以外，还有 Red Hat 的 Quay.io；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务；代码托管平台 GitHub 推出的 ghcr.io。<br>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。<br>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。<br>私有：<br>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。<br>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。<br>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="Docker对比传统虚拟化有什么优势？"><a href="#Docker对比传统虚拟化有什么优势？" class="headerlink" title="Docker对比传统虚拟化有什么优势？"></a>Docker对比传统虚拟化有什么优势？</h2><p>Docker相较于传统虚拟化相比有以下优势</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><p>特性        容器            虚拟机<br>启动        秒级            分钟级<br>硬盘使用    一般为 MB        一般为 GB<br>性能        接近原生        弱于<br>系统支持量    单机支持上千个容器 一般几十个</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zabbix学习记录_1</title>
    <link href="/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是zabbix？"><a href="#什么是zabbix？" class="headerlink" title="什么是zabbix？"></a>什么是zabbix？</h2><p>zabbix是一个监控软件，其可以监控各种网络参数，保证企业服务架构安全运营，同时支持灵活的告警机制，可以使得运维人员快速定位故障、解决问题。zabbix支持分布式功能，支持复杂架构下的监控解决方案，也支持web页面，为主机监控提供了良好直观的展现。<br>zabbix官网地址为<a href="https://www.zabbix.com/">https://www.zabbix.com/</a></p><h2 id="zabbix组成"><a href="#zabbix组成" class="headerlink" title="zabbix组成"></a>zabbix组成</h2><h3 id="zabbix-server"><a href="#zabbix-server" class="headerlink" title="zabbix server"></a>zabbix server</h3><p>概念：核心组件，内部存储了所有的配置信息、统计信息和操作信息。zabbix agent会向zabbix server报告可用性、完整性及其他统计信息。</p><h3 id="web页面"><a href="#web页面" class="headerlink" title="web页面"></a>web页面</h3><p>web页面属于zabbix的一部分，通过图形化界面直观展示了监控信息，方便运维人员监控管理。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>zabbix使用数据库，存储监控数据。</p><h3 id="zabbix-proxy"><a href="#zabbix-proxy" class="headerlink" title="zabbix proxy"></a>zabbix proxy</h3><p>这里不得不说到zabbix的三种部署方式，server-client，server-proxy-client，server-node-client，在不同网络架构下部署不同的模式，具体差别请自行搜索，这里不再赘述。<br>zabbix proxy可以根据具体生产环境进行采用或者放弃。如果使用了zabbix proxy，则其会替代zabbix server采集数据信息，可以很好的分担zabbix server的负载。zabbix proxy通常运用与架构过大、zabbix server负载过重，或者是企业设备跨机房、跨网段、zabbix server无法与zabbix agent直接通信的场景。</p><h3 id="zabbix-Agent"><a href="#zabbix-Agent" class="headerlink" title="zabbix Agent"></a>zabbix Agent</h3><p>zabbix agent通常部署在被监控目标上，用于主动监控本地资源和应用程序，并将监控的数据发送给zabbix server。</p><h2 id="zabbix是怎样工作的？"><a href="#zabbix是怎样工作的？" class="headerlink" title="zabbix是怎样工作的？"></a>zabbix是怎样工作的？</h2><p>zabbix在进行监控时，agent作为zabbix客户端被安装在被监控设备上，负责定期收集数据并将其转发给zabbix服务端，服务端的主要工作是存储数据及提供web服务。<br>zabbix的数据收集分为两种模式：</p><h3 id="1、主动"><a href="#1、主动" class="headerlink" title="1、主动"></a>1、主动</h3><p>客户端主动向服务端请求监控项列表，并主动将收集到的数据提交给服务端。</p><h3 id="2、被动"><a href="#2、被动" class="headerlink" title="2、被动"></a>2、被动</h3><p>由服务端向客户端发起请求监控项列表，随后客户端返回信息到服务端。</p><p>主被关系均以zabbix客户端为基准</p><h2 id="zabbix的工作进程有哪些？"><a href="#zabbix的工作进程有哪些？" class="headerlink" title="zabbix的工作进程有哪些？"></a>zabbix的工作进程有哪些？</h2><p>在默认的情况下，zabbix有6个工作进程；分别是 zabbix_agentd，zabbix_get，zabbix_proxy，zabbix_sender，zabbix_server 和 zabbix_gateway。<br>其中，zabbix_java_gateway是可选进程。（监控JMX虚拟机）</p><h3 id="1、zabbix-agentd"><a href="#1、zabbix-agentd" class="headerlink" title="1、zabbix_agentd"></a>1、zabbix_agentd</h3><p>zabbix-agentd为zabbix客户端守护进程 ，主要负责收集客户端监控项数据。</p><h3 id="2、zabbix-server"><a href="#2、zabbix-server" class="headerlink" title="2、zabbix_server"></a>2、zabbix_server</h3><p>zabbix_server为zabbix服务端守护进程，主要负责收集zabbix客户端数据。（端口为10051）（固定端口吗？）</p><h3 id="3、zabbix-proxy"><a href="#3、zabbix-proxy" class="headerlink" title="3、zabbix_proxy"></a>3、zabbix_proxy</h3><p>zabbix_proxy是zabbix的代理程序，其功能类似于server，作用上类似于一个中转站，最终会把收集的数据再次提交给zabbix_server。</p><h3 id="4、zabbix-get"><a href="#4、zabbix-get" class="headerlink" title="4、zabbix_get"></a>4、zabbix_get</h3><p>zabbix_get作为zabbix工具，通常运行在zabbix_server或者zabbix_proxy上，用于远程获取客户端信息，通常用于排错。</p><h3 id="5、zabbix-sender"><a href="#5、zabbix-sender" class="headerlink" title="5、zabbix_sender"></a>5、zabbix_sender</h3><p>zabbix_sender也是zabbix的一个工具，通常运行在zabbix的客户端，用于耗时比较长的检查，其作用是主动发送数据。</p><h3 id="6、zabbix-java-gateway"><a href="#6、zabbix-java-gateway" class="headerlink" title="6、zabbix_java_gateway"></a>6、zabbix_java_gateway</h3><p>zabbix_java_gateway是zabbix2.0以后引入的新功能，可以用于JAVA方面的设备；但是只能主动获取数据，而不能被动获取数据。</p><h2 id="zabbix具体能有哪些监控？"><a href="#zabbix具体能有哪些监控？" class="headerlink" title="zabbix具体能有哪些监控？"></a>zabbix具体能有哪些监控？</h2><p>硬件监控：通过IPMI接口进行监控，监控对象的物理特征，如电压、温度、风扇状态、电源状态等<br>系统监控：zabbix agent interface，通过专用的代理程序进行监控，与常见的master&#x2F;agent模式类似，如果被监控对象支持对应的agent，推荐首选这种模式<br>java监控：zabbix JMX interface，通过JMX进行监控，JMX(java扩展管理)，通常用于监控JVM虚拟机<br>网络设备监控：zabbix snmp interface，通过snmp协议与被监控对象进行通信，通常来讲，无法在如路由器，交换机这种网络设备上安装agent，但是这些设备通常都支持snmp协议<br>应用服务监控、MYSQL数据库监控、URL监控<br>网络设备监控，系统监控，硬件监控为重点。</p><h2 id="zabbix的常用术语"><a href="#zabbix的常用术语" class="headerlink" title="zabbix的常用术语"></a>zabbix的常用术语</h2><h3 id="1、主机（host）"><a href="#1、主机（host）" class="headerlink" title="1、主机（host）"></a>1、主机（host）</h3><p>要监控的设备，可以由IP或者是主机名（必须可解析）指定。</p><h3 id="2、主机组（host-group）"><a href="#2、主机组（host-group）" class="headerlink" title="2、主机组（host group）"></a>2、主机组（host group）</h3><p>主机的逻辑容器，包含主机和模板，主机组通常在给用户或者是用户组指派监控权限时使用。</p><h3 id="3、监控项（item）"><a href="#3、监控项（item）" class="headerlink" title="3、监控项（item）"></a>3、监控项（item）</h3><p>一个特定监控指标的相关数据，比如内存的大小、CPU的使用率，甚至是服务的运行状态等等。监控项数据来源于被监控对象，并且每个监控项都由一个key来标识。</p><h3 id="4、触发器（trigger）"><a href="#4、触发器（trigger）" class="headerlink" title="4、触发器（trigger）"></a>4、触发器（trigger）</h3><p>一个表达式，用于评估监控项的值是否在合理的范围内。当接收的值超出触发器的规定时，就被认为是故障，如果超出后再次符合，就被认为是正常，也就意味着这是一个过程，it运维小分队里的告警机器人用的就是该项。</p><h3 id="5、事件（event）"><a href="#5、事件（event）" class="headerlink" title="5、事件（event）"></a>5、事件（event）</h3><p>触发器触发的一个特定事件，或者是zabbix定义的一个自动上线注册主机的事件。</p><h3 id="6、动作（action）"><a href="#6、动作（action）" class="headerlink" title="6、动作（action）"></a>6、动作（action）</h3><p>指根据配置，zabbix对于触发器触发的特定事件进行处理的具体措施，如执行某个脚本，或者是向管理员邮箱发送邮件等等。</p><h3 id="7、报警升级（escalation）"><a href="#7、报警升级（escalation）" class="headerlink" title="7、报警升级（escalation）"></a>7、报警升级（escalation）</h3><p>发送警报或者是执行远程命令的自定义方案。</p><h3 id="8、媒介（media）"><a href="#8、媒介（media）" class="headerlink" title="8、媒介（media）"></a>8、媒介（media）</h3><p>发送通知（告警）的手段，如微信、邮件、钉钉等等。</p><h3 id="9、通知（notification）"><a href="#9、通知（notification）" class="headerlink" title="9、通知（notification）"></a>9、通知（notification）</h3><p>通过指定的媒介，向用户发送的有关事件的信息。</p><h3 id="10、远程命令（remote-command）"><a href="#10、远程命令（remote-command）" class="headerlink" title="10、远程命令（remote command）"></a>10、远程命令（remote command）</h3><p>指运维人员提前写好的命令，可以让被监控主机在触发事件后执行。</p><h3 id="11、模板（template）"><a href="#11、模板（template）" class="headerlink" title="11、模板（template）"></a>11、模板（template）</h3><p>用于快速定义被监控主机的预设条目集合，通常包括了监控项、触发器、应用等，模板可以直接链接至某个主机。</p><h3 id="12、应用（application）"><a href="#12、应用（application）" class="headerlink" title="12、应用（application）"></a>12、应用（application）</h3><p>一组监控项的集合。</p><h3 id="13、web场景（web-scennario）"><a href="#13、web场景（web-scennario）" class="headerlink" title="13、web场景（web scennario）"></a>13、web场景（web scennario）</h3><p>用于检测web站点可用性的一个或多个HTTP请求。</p><h3 id="14、前端（frontend）"><a href="#14、前端（frontend）" class="headerlink" title="14、前端（frontend）"></a>14、前端（frontend）</h3><p>zabbix的web接口。</p><p>通过本次学习，对zabbix有了初步的了解。</p>]]></content>
    
    
    <categories>
      
      <category>网络运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>zabbix</tag>
      
      <tag>运维监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>winget工具概述</title>
    <link href="/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="WinGet概述"><a href="#WinGet概述" class="headerlink" title="WinGet概述"></a>WinGet概述</h1><p>以下资料来源于微软社区：<a href="https://learn.microsoft.com/zh-cn/windows/package-manager/">https://learn.microsoft.com/zh-cn/windows/package-manager/</a></p><h2 id="什么是WinGet？"><a href="#什么是WinGet？" class="headerlink" title="什么是WinGet？"></a>什么是WinGet？</h2><p>Windows软件包管理器 (WinGet) 是一个工具，帮助用户在Windows系统上发现和安装软件包。项目包括命令行界面 (CLI)、PowerShell模块和组件对象模型 (COM) API。客户端可以访问来自Microsoft Store和WinGet社区库的包,同时支持自建软件源访问。</p><h2 id="什么系统支持使用WinGet？"><a href="#什么系统支持使用WinGet？" class="headerlink" title="什么系统支持使用WinGet？"></a>什么系统支持使用WinGet？</h2><p>Windows 10（1809）以后的版本，会自动安装WinGet工具。在此之前的windows系统需要手动安装，在微软商店。<br>windows 10 （1709）以后都支持使用，但是有一个前提条件，必须更新微软商店，原因是windows11采取了新的微软商店并强制要求所有商店更新至该版本否则不能使用。由于是新系统下的商店，很多依赖项在win10上是没有的，需要手动去安装，具体参考文章windows 10下安装winget。<br>最低支持版本：<br>winget 命令行工具仅在 Windows 10 1709（版本 16299）或更高版本上受支持。 在你首次以用户身份登录 Windows（这会触发 Microsoft Store 将 Windows 程序包管理器注册为异步进程的一部分）之前，winget 工具不可用。 如果最近已经以用户身份进行了首次登录，但发现 winget 尚不可用，则可以打开 PowerShell 并输入以下命令来请求此 winget 注册：Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe。</p><h2 id="WinGet支持哪些安装程序？"><a href="#WinGet支持哪些安装程序？" class="headerlink" title="WinGet支持哪些安装程序？"></a>WinGet支持哪些安装程序？</h2><p>● EXE（具有 Silent 和 SilentWithProgress 标志）<br>● ZIP<br>● INNO<br>● NULLSOFT<br>● MSI<br>● WIX<br>● APPX<br>● MSIX<br>● BURN<br>● PORTABLE</p><h3 id="WinGet的下载"><a href="#WinGet的下载" class="headerlink" title="WinGet的下载"></a>WinGet的下载</h3><p>这里提供一个稳定版本1.8.1522<br>github地址:<a href="https://github.com/microsoft/winget-cli/releases">https://github.com/microsoft/winget-cli/releases</a></p><h2 id="WinGet应用场景"><a href="#WinGet应用场景" class="headerlink" title="WinGet应用场景"></a>WinGet应用场景</h2><p><img src="/img/winget_1.png" alt="winget_1"><br><img src="/img/winget_2.png" alt="winget_2"></p><p>通过以上方法，提升了网络整体安全性，避免了终端用户从不安全网站下载非法应用所带来的内网安全隐患。同时，通过使用批处理脚本实现批量安装应用程序，减少了重复工作，提高了工作效率。</p><h2 id="WinGet软件源的搭建"><a href="#WinGet软件源的搭建" class="headerlink" title="WinGet软件源的搭建"></a>WinGet软件源的搭建</h2><p>准备工作，创建软件清单<br>这里用wingetcreate来实现软件清单创建<br>通过winget命令install wingetcreate（建议连接vpn，这里可能因为网络因素安装失败）<br>寻找需要的软件包，获取其下载链接。<br>通过wingetcreate new install url，来获取清单。<br>可以通过 wingetcreate.exe update –urls 来更新清单。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a></p><h3 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h3><p>由于winget要求软件源必须使用HTTPS，所以需要通过nginx的反向代理来实现访问。<br>安装过程不在这里赘述，贴一张nginx配置文件提供参考。</p><h3 id="搭建Rewinged"><a href="#搭建Rewinged" class="headerlink" title="搭建Rewinged"></a>搭建Rewinged</h3><p>Rewinged 是一个自托管的 winget 包源工具，可以运行在 Linux、Windows、Docker 或云环境中。它通过读取目录中的包清单，并通过 REST API 使这些包可以被 winget 客户端搜索和访问。这使得用户可以创建和管理自己的私有 winget 包源，而无需依赖于云服务，winget 要求 REST 源使用 HTTPS - 不允许明文 HTTP。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a><br>封装好的程序包地址：<a href="https://github.com/jantari/rewinged/releases">https://github.com/jantari/rewinged/releases</a></p><ol><li>将wingetcreate创建的清单移至服务器，Rewinged 对应目录下（wingetcreate及winget仅可在Windows运行，若操作系统为其他则需要手动填写清单，或将wingetcreate创建的清单移到对应文件夹中）</li><li>通过参数configFile可以将所有参数写成一个json来执行</li><li>命令行执行，运行Rewinged并在后台运行，在rg目录下会有一个日志文件生成<br>nohup .&#x2F;rewinged -configFile &#x2F;rg&#x2F;rewinged.json<br>以下是一个基础的配置文件<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;autoInternalize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/installers&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizeSkip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;https&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsCertificateFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.crt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsPrivateKeyFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.key&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:3000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;logLevel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;info&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;manifestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/manifests&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>这里要讲一个参数的功能，-autoInternalize开启自动内化，启用后会将软件清单内的下载URL自动下载到本地指定文件夹，从而实现在不连接外网仅连接内网的情况下安装软件。第一次启用该功能会有一个下载软件的过程，在此过程中直接下载则会显示哈希认证不完整，必须等软件包被完整下载才可以正常使用。(从下载url到指定文件夹的这个过程可能会失败，每个软件都需要下载测试一下)<br>这里说一下如果安装包hash校验不通过或者下载不完整怎么处理。<br>首先下载一个完整的安装包，将exe后缀去除使其变为文件，随后打开cmd页面输入命令“winget hash 文件路径”生成文件的哈希值。<br>随后找到rewinged目录下，修改对应软件目录下的installer文件</li></ol><p>替换yaml文件内的哈希值为你下载的软件包哈希</p><p>随后到installers目录下，删除原先的软件包，将新下载的软件名称修改为哈希值（通过哈希值为索引），重启rewinged工具，完成替换。<br>扩展参数<br>这些命令行配置是用于配置和运行 <code>rewinged</code> 应用程序的参数。下面是每个参数的详细解释：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-autoInternalize<br><span class="hljs-bullet">   -</span> 作用：开启自动内部化功能。<br><span class="hljs-bullet">   -</span> 说明：启用此功能后，应用程序会自动将一些内容进行内部处理。<br><br>-autoInternalizePath string<br><span class="hljs-bullet">   -</span> 作用：指定自动内部化安装程序存储的目录。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./installers&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：自动内部化的安装程序将被存储在这个指定的目录中。<br><br>-autoInternalizeSkip string<br><span class="hljs-bullet">   -</span> 作用：指定排除在自动内部化之外的主机名列表。<br><span class="hljs-bullet">   -</span> 说明：可以用逗号或空格分隔多个主机名，这些主机将不进行自动内部化处理。<br><br>-configFile string<br><span class="hljs-bullet">   -</span> 作用：指定一个 JSON 配置文件的路径。<br><span class="hljs-bullet">   -</span> 说明：这个文件是可选的，可以用来提供额外的配置选项。<br><br>-https<br><span class="hljs-bullet">   -</span> 作用：直接从 <span class="hljs-code">`rewinged`</span> 应用程序提供加密的 HTTPS 流量，而无需代理。<br><span class="hljs-bullet">   -</span> 说明：启用此选项后，应用程序将使用 HTTPS 协议。<br><br>-httpsCertificateFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的 Web 服务器证书文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./cert.pem&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：这是应用程序在启用 HTTPS 时使用的证书文件路径。<br><br>-httpsPrivateKeyFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的私钥文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./private.key&quot;`</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**说明**</span>：这是应用程序在启用 HTTPS 时使用的私钥文件路径。<br><br>-listen string<br><span class="hljs-bullet">   -</span> 作用：指定 REST API 监听的地址和端口。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;localhost:8080&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：应用程序的 REST API 将在这个地址和端口上进行监听。<br><br>-logLevel string<br><span class="hljs-bullet">   -</span> 作用：设置日志的详细程度。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;info&quot;`</span><br><span class="hljs-bullet">   -</span> 可选值：<span class="hljs-code">`disable`</span>, <span class="hljs-code">`error`</span>, <span class="hljs-code">`warn`</span>, <span class="hljs-code">`info`</span>, <span class="hljs-code">`debug`</span>, <span class="hljs-code">`trace`</span><br><span class="hljs-bullet">   -</span> 说明：用于控制应用程序的日志输出详细程度。<br><br>-manifestPath string<br><span class="hljs-bullet">    -</span> 作用：指定搜索包清单文件的目录。<br><span class="hljs-bullet">    -</span> 默认值：<span class="hljs-code">`&quot;./packages&quot;`</span><br><span class="hljs-bullet">    -</span> 说明：应用程序将在这个目录中搜索包清单文件。<br><br>-version<br><span class="hljs-bullet">    -</span> 作用：打印版本信息并退出。<br><span class="hljs-bullet">    -</span> 说明：运行时不会启动应用程序，而是打印当前版本信息。<br></code></pre></td></tr></table></figure><h2 id="WinGet工具的使用"><a href="#WinGet工具的使用" class="headerlink" title="WinGet工具的使用"></a>WinGet工具的使用</h2><p>常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">● winget show 软件名  <span class="hljs-comment">#查询软件库中软件信息，该命令支持中文检索</span><br>● winget install --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#安装软件，通过查询软件名可知id号，通过id号来安装，避免因为软件名称混淆导致的安装失败（在WinGet自带的软件库中，就存在QQ、腾讯QQ，以及不同来源的QQ，直接使用软件名安装可能会导致安装失败）</span><br>● winget uninstall --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#卸载软件，使用id号原因同上</span><br>● winget upgrade --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#更新软件，从软件库中获取更新</span><br>● winget list  <span class="hljs-comment">#查询安装的应用程序</span><br></code></pre></td></tr></table></figure><p>已管理员的身份启动命令行，执行“ winget source add -n qunhe -a <a href="https://winget.qunhequnhe.com/api">https://winget.qunhequnhe.com/api</a> -t “Microsoft.Rest”，随后“winget install 软件名 -s qunhe”即可。<br>这里我写一个bat脚本，能够自动执行添加软件源及安装小酷助手、企业微信、WPS及腾讯会议。有特殊需求直接修改这个脚本即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@echo off<br>echo Installing standard software...<br>winget <span class="hljs-selector-tag">source</span> add -n qunhe -<span class="hljs-selector-tag">a</span> https:<span class="hljs-comment">//winget.qunhequnhe.com/api -t &quot;Microsoft.Rest&quot;</span><br>winget install qunhe<span class="hljs-selector-class">.xiaoku</span> qunhe<span class="hljs-selector-class">.qiyeweixin</span>  KingsoftCorp<span class="hljs-selector-class">.Ltd</span><span class="hljs-selector-class">.WPSOffice</span> Tencent<span class="hljs-selector-class">.WeMeet</span> -s qunhe<br>echo Installation complete.<br></code></pre></td></tr></table></figure><p>功能测试：<br><img src="/img/winget_3.png" alt="winget_3"><br>需要注意以下几点，</p><ol><li>win系统必须带有winget</li><li>必须能解析winget.qunhequnhe.com这个域名如果不可以可能是你的dns服务器设置的有问题，可以尝试使用10.1.102.201<br>拓展参数：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">install</span>    安装给定的程序包<br>  show       显示包的相关信息<br>  source     管理程序包的来源<br>  search     查找并显示程序包的基本信息<br>  list       显示已安装的程序包<br>  upgrade    显示并执行可用升级<br>  uninstall  卸载给定的程序包<br>  hash       哈希安装程序的帮助程序<br>  validate   验证清单文件<br>  settings   打开设置或设置管理员设置<br>  features   显示实验性功能的状态<br>  ex<span class="hljs-keyword">port</span>     导出已安装程序包的列表<br>  <span class="hljs-keyword">import</span>     安装文件中的所有程序包<br>  pin        管理包钉<br>  configure  将系统配置为所需状态<br>  download   从给定的程序包下载安装程序<br>  repair     修复所选包<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>IT技术支持</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>winget</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
