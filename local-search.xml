<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SRE-Google运维解密-第八章发布工程</title>
    <link href="/2024/09/19/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B/"/>
    <url>/2024/09/19/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>考虑到本书的内容较多，从本章节开始不再长篇大论，而是尽量精简的表达该章节的意思。（不然每一章要码几k字阅读效率太低了）</strong><br>本章节详细讲述了Google是如何通过发布工程来管理软件的发布过程，介绍以此衍伸出的发布工程师在这一过程中所扮演的关键角色，发布工程是SRE中非常重要的一个环节，其确保软件可以被稳定、快速且可控的从开发环境推向生产环境。</p><h2 id="角色：发布工程师"><a href="#角色：发布工程师" class="headerlink" title="角色：发布工程师"></a>角色：发布工程师</h2><p>发布工程师在软件生命周期中扮演着重要的角色，其主要工作职能包括设计、开发和维护用于发布软件工具和流程。确保这些过程是可重复的、可自动化的且符合团队的需求和质量标准。</p><h3 id="核心职责"><a href="#核心职责" class="headerlink" title="核心职责"></a>核心职责</h3><p>设计并维护发布流程<br>开发自动化工具来支持构建、测试和部署<br>确保发布流程的一致性和可靠性<br>提供发布过程中的技术支持，确保任何问题都能快速得到解决</p><h2 id="哲学：发布工程"><a href="#哲学：发布工程" class="headerlink" title="哲学：发布工程"></a>哲学：发布工程</h2><p>发布工程的核心目标是使过程尽可能简单、高效且可控。为了这个目标，Google的发布工程团队设计了一套系统（自研啊…Rapid系统），使开发者可以通过自服务的方式自行进行发布操作，而不需要依赖于运维团队的手动操作。<br><strong>自服务模型：</strong><br>自服务模型是Google发布工程的一个重要组成部分，通过提供一系列自动化工具和平台，开发团队可以在不依赖SRE团队的情况下，完成从代码提交到生产环境发布的全过程。<br>这种模式不仅提高了发布速度，还减少了发布过程中可能出现的瓶颈。<br><strong>追求速度与可靠性：</strong><br>发布工程师不仅要追求快速的发布速度，还必须确保发布过程的高可靠性。为了平衡这两者，Google使用了高度自动化的工具和流程，来确保系统在发布时不会因为速度而牺牲质量。</p><h2 id="发布流程的各个阶段"><a href="#发布流程的各个阶段" class="headerlink" title="发布流程的各个阶段"></a>发布流程的各个阶段</h2><p>持续构建与部署：</p><p>构建：构建是发布的第一步，发布工程师需要确保代码可以在不同的环境中顺利构建。Google使用自动化构建工具来确保构建的一致性，并通过构建服务器来管理和执行构建任务。</p><p>分支管理：分支管理是发布过程中的重要环节，特别是当多个团队同时开发多个特性时，必须保证分支的稳定性和同步。发布工程师负责管理分支的合并策略，确保新功能和修复能够按计划进入生产环境。</p><p>测试：在发布前，自动化测试是确保代码质量的关键步骤。Google发布工程通过自动化测试框架，涵盖了单元测试、集成测试、性能测试等多种测试方式，确保代码在进入生产环境前能够通过全面的测试。</p><p>打包：打包过程将构建好的代码和资源打包成一个可部署的单位。发布工程师需要确保打包过程能够正确执行，且最终的打包结果是可重复的，并可以直接部署到目标环境中。</p><h2 id="强调策略和流程"><a href="#强调策略和流程" class="headerlink" title="强调策略和流程"></a>强调策略和流程</h2><p>发布工程不仅局限于发布，还强调在发布过程的整体策略和流程，让每个发布环节遵循既定的标准，以免因失误引发系统故障。（更新是导致系统故障的最大原因）<br>策略的作用：<br>策略在发布过程中非常重要。发布工程师需要确保每个步骤都有严格的策略控制，避免不当的操作可能带来的风险。比如，某些高风险功能可能需要通过特定的灰度发布策略，逐步放量给用户。</p><p>持续改进流程：<br>发布流程不是一成不变的。发布工程师会根据团队的需求和项目的变化，持续优化和改进发布流程。这意味着流程会根据实际情况进行调整，以保证效率和质量。</p><h2 id="不仅仅对Google有用"><a href="#不仅仅对Google有用" class="headerlink" title="不仅仅对Google有用"></a>不仅仅对Google有用</h2><p>发布工程并不是等到项目规模庞大时才需要关注的内容，而是应该从一开始就作为项目的一部分来规划。这样可以从最初就减少发布过程中可能遇到的问题，确保项目的可维护性和可扩展性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第8章详细讲解了Google如何通过发布工程来确保软件的高效、可靠发布。发布工程师的角色至关重要，他们负责管理从构建、测试到部署的整个过程，并通过自动化工具和策略确保系统的发布流程简洁且高效。这一章强调了发布的自动化、自服务模式的重要性，并且给出了一些在大型组织中如何管理复杂发布流程的实用建议。</p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE-Google运维解密-第七章Google的自动化系统的演进</title>
    <link href="/2024/09/10/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%B8%83%E7%AB%A0Google%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B/"/>
    <url>/2024/09/10/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%B8%83%E7%AB%A0Google%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章可以说是我读这本书以来，最难理解的一章节。相对的，本章的内容也非常有意思，讲述了Google随着规模扩大，是如何从一个手动操作维护的系统到一个自动化系统，最后演变为一个自治系统的过程。<br><strong>“黑科技”之外，就只剩自动化和机械化了。</strong><br><strong>对于SRE而言，自动化是一种力量倍增器，但不是万能药。</strong></p><h2 id="自动化的价值"><a href="#自动化的价值" class="headerlink" title="自动化的价值"></a>自动化的价值</h2><p>自动化所带来的价值有以下几点：</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>随着系统规模的扩大，工程师们不得不的做一些机械性，重复的操作来履行职责。这种一个人或一群人，手动执行数百次动作时，没法保证每次都用同样的方式进行，没人能保证像机器一样永远保持一致。这种不可被避免的不一致性会导致错误、疏漏、数据质量的问题和可靠性，同时会浪费时间，这在有关琐事那章有提到。<br>所以需要自动化来确保一致性，一致的执行范围明确、步骤已知的程序。<br>这是自动化的首要价值。</p><h3 id="平台性"><a href="#平台性" class="headerlink" title="平台性"></a>平台性</h3><p>自动化所建立的平台系统可以为工程师带来一个可以扩展、广泛适用的、可能带来额外收益的平台。通过正确的设计和实现，将自动化系统大规模应用，降低成本，提高效应。<br>书中将手动操作比做“额外的交付税务”，因为其成本高，而且难以扩展。<br>平台系统还能做到“错误集中修复”，自动化平台将错误的处理集中化，这意味着如果某个错误在代码中被修复，那么这次修复将会对所有相关的系统生效。集中化的处理减少了相同错误在不同部分重复发生的风险，提高系统整体稳定性。<br>自动化平台还能做到持续运行和暴露自己性能指标，减轻人类的工作负担，更进一步优化系统性能或避免系统错误。</p><h3 id="修复速度更快"><a href="#修复速度更快" class="headerlink" title="修复速度更快"></a>修复速度更快</h3><p>自动化系统能够更快的解决系统中的常见故障，而不需要人工介入，这种方式能大大加快故障修复的速度和减少工作量。<br>书里提到了一个指标“MTTR”（平均修复时间），指从问题发生到修复完成的时间。这也是自动化系统的优势所在，能在问题发生的瞬间立刻采取行动，快速解决问题，降低了MTTR，提高了整体效率，让工程师把更多的精力投入到其他更有价值的任务中去。<br>一个产品在开发和运营过程就像是建大楼，问题发现的越早，修改的成本就越低，尤其是在投入生产环境中的问题通常既耗时又昂贵，自动化系统可以在问题发生后迅速处理，这也降低了总体的维护成本。<br>最后提到了规模，大规模的生产系统如果出现故障，处理起来复杂且频繁，有时甚至是人工无法处理（在短时间内），而自动化系统能够有效的应对这种情况，减少人工干预，进而降低整个系统的运营成本。（前提是大规模）</p><h3 id="行动速度更快"><a href="#行动速度更快" class="headerlink" title="行动速度更快"></a>行动速度更快</h3><p>自动化系统的反应速度比人类更快，特别是在某些情况下，比如流量调整，自动化系统可以立即采取行动，而人类操作员可能需要更多时间做出反应，又或者是故障转移。<br>但使用自动化并非没有风险，自动化在某些情况下让问题变得更糟糕，但这也是为什么要明确自动化程序的适用范围。通过精心设计，让自动化在特定场景下发挥最佳作用，避免出现问题。<br>在大规模的公司中，自动化已成为必不可少的存在。如果没有自动化，很多服务由于其规模和复杂性，早已超过人工操作所能管理的限度，只有依赖自动化系统才能让这些大规模系统正确、长久的运行。</p><h3 id="节省时间"><a href="#节省时间" class="headerlink" title="节省时间"></a>节省时间</h3><p>自动化常被认为是节省时间的一种手段，受到大家的普遍认可。在短期内这种优势并不明显，也不容易量化，因为初开发的自动化系统需要投入大量的时间和精力去打磨。<br>自动化的长期收益体现在如果某一工程师完成某一个自动化工具，使某一任务被自动化，这意味着任何人都可以使用这个自动化工具，不仅节省了开发者的时间，还可以为团队或公司中的其他人节省时间。<br>自动化将任务执行与具体操作的人分开，不在需要特定的人来手动执行某些操作，这种解耦性大大提高了效率和灵活性。<br>最后，如果不努力自动化，那它（系统）就会耗费大量的人工精力，最终导致效率低下，这将像是在用“人力资源”在喂养机器。</p><h2 id="自动化对Google-SRE的价值"><a href="#自动化对Google-SRE的价值" class="headerlink" title="自动化对Google SRE的价值"></a>自动化对Google SRE的价值</h2><p>Google对全球提供各种各样的产品服务，这意味着其规模超乎想象。不可能采用手动管理这种效率低下、难以保持一致性和可靠性。因此，Google需要使用自动化来确保产品服务的运行。<br>通过上述观点，可以总结出自动化的三大优点：一致性（确保所有系统和服务按照预期运行，减少人为错误）、快速性（远超人类管理员的响应和修复问题速度）、可靠性（通过标准化流程降低出错概率，提高了系统的稳定性）<br>Google的环境是独特的，是高度统一和复杂的，这使他们能够更好地控制和管理系统。避免使用没有api或不提供源码的软件，减少外部因素对内部系统的影响。<br>倾向于自主开发系统，即使购买现成的软件可能更便宜，但是出于长期考虑，自主开发系统明显更具价值。（系统无法复制，思想可以借鉴）<br>还有以下几点：<br><strong>自动化系统的开发：</strong> Google在自动化管理系统方面投入了大量时间和精力。他们不仅仅是自动化系统操作，还自动化了系统管理本身，这使得他们在大规模生产环境中的系统管理更高效。</p><p><strong>对技术栈的控制：</strong> Google的SRE团队可以访问几乎所有与他们相关的系统的源代码。这意味着他们能够完全控制技术栈，从底层硬件到应用程序层。这种控制使得他们能够更加轻松地在生产环境中进行管理和维护。</p><p><strong>平台化方法：</strong> Google不仅仅是将系统组件逐一自动化，而是致力于创建平台。这种平台化的思路使得系统在未来更加容易扩展和管理。他们的理念是，平台为基础的方法在可管理性和可扩展性上至关重要。</p><p><strong>灵活性和现实情况：</strong> 尽管Google倾向于全面自动化，但并不是所有系统一开始就设计为可自动化的。一些系统从快速原型开始，可能并没有打算长期运行或全面自动化。这意味着即使Google在自动化上有着强烈的倾向，他们仍然会根据实际情况进行调整。</p><h2 id="自动化的应用案例"><a href="#自动化的应用案例" class="headerlink" title="自动化的应用案例"></a>自动化的应用案例</h2><p><strong>自动化是一种操作其他软件或系统的“元软件”</strong><br>这一节强调了自动化在运维中的重要性，尤其是在类似于Google这样的大型公司。自动化节省的不只是时间，还提高了系统的一致性、快速性和可靠性。同时指出了，自动化系统在设计和实施中可能面临的挑战难题，展示了手动化-自动化-自治系统的过程。<br>对案例感兴趣的话，可以自行查阅。<br>这里要讲一下其中的一个案例，自治系统Borg，在现在与其类似的是k8s，这个可以后面再讨论。</p><h2 id="可靠性是最基本的功能"><a href="#可靠性是最基本的功能" class="headerlink" title="可靠性是最基本的功能"></a>可靠性是最基本的功能</h2><p>本节讨论了自动化对系统操作和可靠性的影响，虽然自动化能处理越来越多的日常任务、提升系统效率、减轻管理员负担。但是长期依赖自动化对让管理员逐渐失去对系统的直接掌控，如果遇到自动化系统故障或无法解决的问题，管理员会因为缺乏实践而无法快速应对这些故障。<br>随着管理员和系统直接接触变少，其对系统的理解（这里称呼为“心理模型”）会逐渐与系统实际的运行脱轨。出现这种情况会导致管理员无法有效的诊断和修复问题，因为系统的预期和实际并不相符。<br>手动化的消失也会导致管理员无法像之前那样操作系统，因为这一过程已被移除或被自动化替代。<br>在某些情况下，自动化系统的错误也会导致更大规模的影响。但总的来说，在大规模服务中，自动化和自主性已成为必须，因为它们可以提高系统的可靠性和弹性，这是手动化远远无法达到的。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>本章节的最后，Google的SRE工程师们给出了他们对于自动化的建议。<br>自动化应在早期执行，且不局限于大规模系统。尤其是在设计阶段，通过解耦子系统、引入API、减少副作用等措施，使系统更具弹性，减少后期成本。<br>理解自动化系统大规模故障的风险和自动化设计中的缺陷，对自动化系统要有充分的测试，加入限制措施（比如减慢执行速率，避免出现错误操作在一瞬间完成），检查系统的幂等性，确保操作的安全险。<br>最后，做好良好的容量规划，做好备份，让问题的影响被控制在最小范围。</p><p><strong>本章完</strong></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE-Google运维解密-第六章分布式系统监控</title>
    <link href="/2024/08/29/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
    <url>/2024/08/29/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>监控可以说是运维的眼和耳，是IT基础设施中重要的一部分，善用监控能提高运维效率，避免运维故障。其与第四章服务质量目标相结合，意在表达监控的重要性。本文讨论了google内部对监控的一些看法和指导意见，值得参考。</p><h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><p>目前并没有通用的监控术语，即使是在谷歌的内部。<br>本文提供了一些绝大部分情况下，通用的监控术语。</p><h3 id="监控（monitoring）"><a href="#监控（monitoring）" class="headerlink" title="监控（monitoring）"></a>监控（monitoring）</h3><p>收集、处理、汇总，并且显示关于某个系统的实时量化数据。</p><h3 id="白盒监控（white-box-monitoring）"><a href="#白盒监控（white-box-monitoring）" class="headerlink" title="白盒监控（white-box monitoring）"></a>白盒监控（white-box monitoring）</h3><p>依靠系统内部暴露的一些性能指标进行监控。这里作一个咖啡机的比喻，白盒监控的是内部的零件、线路。</p><h3 id="黑盒监控（black-box-monitoring）"><a href="#黑盒监控（black-box-monitoring）" class="headerlink" title="黑盒监控（black-box monitoring）"></a>黑盒监控（black-box monitoring）</h3><p>通过测试某种外部用户可见的系统进行监控。还是咖啡机的比喻，这次监控的不是咖啡机本身，而是由咖啡机所生产出来的咖啡的质量。</p><h3 id="监控台页面（dashboard）"><a href="#监控台页面（dashboard）" class="headerlink" title="监控台页面（dashboard）"></a>监控台页面（dashboard）</h3><p>可视化页面，跟之前公司的数据小站类似。提供某个服务核心指标一览服务的应用程序（一般是基于Web的）​，提供过滤、选择等功能，但最主要的功能是可视化数据，提供数据分析页面。</p><h3 id="警报（alert）"><a href="#警报（alert）" class="headerlink" title="警报（alert）"></a>警报（alert）</h3><p>目标对象是某人发向某个系统地址的一个通知。目的地可以包括工单、邮箱、聊天软件等。<br>警报也分类别和等级。</p><h3 id="根源问题（root-cause）"><a href="#根源问题（root-cause）" class="headerlink" title="根源问题（root cause）"></a>根源问题（root cause）</h3><p>我更喜欢叫这个名词为技术债，指系统（软件或流程）中的某种缺陷。不在早期处理这种技术债务，随着时间累加，其的处理成本会越来越大。</p><h3 id="节点或者机器（node-machine）"><a href="#节点或者机器（node-machine）" class="headerlink" title="节点或者机器（node&#x2F;machine）"></a>节点或者机器（node&#x2F;machine）</h3><p>这两个术语是相同的，指代在物理机、虚拟机，或者容器内运行的某个实例。<br>某个单独的物理机器上可能有多个服务需要监控。这些服务可能具有以下特点。</p><h4 id="相互关联的服务"><a href="#相互关联的服务" class="headerlink" title="相互关联的服务"></a>相互关联的服务</h4><p>例如Web服务器与对应的缓存服务器。</p><h4 id="不相关的服务"><a href="#不相关的服务" class="headerlink" title="不相关的服务"></a>不相关的服务</h4><p>它们仅仅共享硬件：例如代码仓库和把文件存放在代码仓库中的配置管理系统的主进程。</p><h3 id="推送（push）"><a href="#推送（push）" class="headerlink" title="推送（push）"></a>推送（push）</h3><p>关于某个服务正在运行的软件或者其配置文件的任何改动。<br>其实就是更新。</p><h2 id="为什么需要监控？"><a href="#为什么需要监控？" class="headerlink" title="为什么需要监控？"></a>为什么需要监控？</h2><p>选择监控的原因有很多，书中举出了几个比较关键的点。</p><h3 id="分析长期趋势"><a href="#分析长期趋势" class="headerlink" title="分析长期趋势"></a>分析长期趋势</h3><p>通过分析长期趋势，得到数据的增长量，跨时间范围的对比，观察实验组之间的区别。<br>这样可以得到某个系统中某个组件是否出现故障，或者说某个组件即将出现故障，让运维人员尽快查看。</p><h3 id="构建监控台页面"><a href="#构建监控台页面" class="headerlink" title="构建监控台页面"></a>构建监控台页面</h3><p>监控台页面会有助于运维人员规划长期或短期运维计划，回答服务的一些基本问题。<br>这里还提到了四个“黄金指标”，非常有用。</p><h3 id="临时性的回溯分析（也就是在线测试）"><a href="#临时性的回溯分析（也就是在线测试）" class="headerlink" title="临时性的回溯分析（也就是在线测试）"></a>临时性的回溯分析（也就是在线测试）</h3><p>如果线上发生故障，比如我们的丢包率突然升高了，<strong>有没有其他现象发生？</strong><br>系统监控在给业务分析提供原始数据和分析安全入侵的场景时也有一定作用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>监控与报警可以让一个系统在发生故障时主动通知我们，或者能够告诉我们即将发生什么。<br><strong>以下摘抄自原文：</strong><br>当系统无法自动修复某个问题时，需要一个人来调查这项警报，以决定目前是否存在真实故障，采取一定方法缓解故障，最终找出导致故障的根源问题。除了是在针对某个非常具体的组件进行安全审计的情况以外，我们不应该仅仅因为“某东西看起来有点问题”就发出警报。紧急警报的处理会占用员工的宝贵时间。如果该员工正在工作时间段，该警报的处理会打断他原本的工作流程。如果该员工正在家，紧急警报的处理则会影响他的个人生活，甚至是把他从睡眠中叫醒。当紧急警报出现得太频繁时，员工会进入“狼来了”效应，怀疑警报的有效性甚至忽略该警报，有的时候在警告过多的时候甚至会忽略掉真实发生的故障。由于无效信息太多，分析和修复可能会变慢，故障时间也会相应延长。高效的警报系统应该提供足够的信息，并且误报率非常低。</p><h2 id="合理的监控预期"><a href="#合理的监控预期" class="headerlink" title="合理的监控预期"></a>合理的监控预期</h2><p>监控本身就是一项复杂的工程。即便在一个成熟的IT基础设施情况下，也需要10-12个人组成的SRE团队中分出1-2人全职进行监控的构建和维护工作。<br>书中指出，google的工程师倾向于简单和快速的监控系统配合高效的工具进行事后分析。这里还提到了一个概念，魔法监控如试图自动学习阈值或自动检测故障原因的系统。google不提倡这种想法，甚至是避免这种情况的产生。<br>原因是什么呢?google举了一个反例：<br><strong>检测最终用户请求速率的意外变化的系统。我们坚持监控系统规则越简单越好，同时要求这些监控规则可以检测某个非常简单、具体，但是严重的异常情况。监控数据的其他用处还包括容量规划、流量预测，用于这些方面的监控规则对错误和稳定性的要求更低，也就可以稍微复杂一些。针对某个试验功能的数据观测，可能时间跨度非常长（数月甚至数年）​，取样率也很低，这种用途可以容忍一定的错误率，因为这些偶尔出现的错误不会掩盖真正的长期趋势。</strong><br>书中还提到了应对复杂依赖关系。<br>什么是复杂依赖关系？就是在某个系统中的某个服务，依赖于该系统中的另一组件，可能是一个模块下，可能不是，可能是另外的架构中的，可能是某一个参数控制的。总之这种复杂依赖关系非常难以处理，令人头疼。<br><strong>针对依赖服务的监控规则，一般只用于系统中非常稳定的组件上。</strong><br>“由于Google基础设施的重构速度很快，很少有团队会在监控系统中维护复杂的依赖关系。”真是凡尔赛啊。<br>本章中讨论到的某些想法还有想象的空间，从现象到根源问题的定位速度可以更快，尤其是在一个不断改变的系统中。这一章给监控系统设立了一些目标，同时提供了一些达到这些目标的方法。<br>但是监控系统中最重要的一点就是整个“生产故障，人工处理紧急警报，简单定位和深入调试”过程必须要保持非常简单，必须能被团队中任何一个人所理解。<br>同样的，监控系统信噪比应该很高，发出紧急警报的组件需要非常简单而且可靠。产生警报的监控系统规则应该非常容易理解，同时代表一个清晰的故障场景。<br><strong>简单可靠高效！</strong></p><h2 id="现象与原因"><a href="#现象与原因" class="headerlink" title="现象与原因"></a>现象与原因</h2><p>书中提到监控系统必须解决两个问题：什么东西出问题了？为什么出故障了？<br>“什么东西出故障了”即为现象（symptom）：“为什么出故障了”则代表了原因。<br><strong>“现象”和“原因”的区分是构建信噪比高的监控系统时最重要的概念！</strong></p><h2 id="黑盒监控和白盒监控"><a href="#黑盒监控和白盒监控" class="headerlink" title="黑盒监控和白盒监控"></a>黑盒监控和白盒监控</h2><p>既然提到了现象与原因，不得不讲一下前面提到的黑、白盒监控了。<br>前面有提到，监测服务端远比监测客户端容易。所以在一个线上系统，实现白盒监控远比黑盒监控容易。<br>书中提到google大量依赖白盒监控，只在关键处使用黑盒监控。<br>最简单区分黑白盒监控的办法是，<strong>黑盒监控是面向现象的，代表了目前正在发生的故障。</strong>而白盒监控依赖于<strong>大量对系统内部信息的监测，代表了即将发生，或已经发生但是因为某种原因而没有表现的故障。</strong><br>书中这里还提到了依赖关系的监控。在一个多层系统中，某一个服务的现象是另外一个服务的原因。<br>举例：例如，数据库性能问题。数据库读操作很缓慢是数据库SRE检测到的一个现象。然而，对前端SRE来说，他们看到的是网站缓慢，数据库读操作的缓慢则是原因。<br>因此，白盒监控有时是面向现象的，有时是面向原因的，这取决于白盒系统所提供的信息。<br>黑盒监控可以保证系统只在某个问题目前正在发生，并且造成了某个现象时才会发出紧急警报。另外一方面，<strong>针对那些还没有发生，但是即将发生的问题，黑盒监控通常是没用的。</strong></p><h2 id="四个黄金指标"><a href="#四个黄金指标" class="headerlink" title="四个黄金指标"></a>四个黄金指标</h2><p>本文前面提到了四个监控的黄金指标，它们分别是延迟、流量、错误和饱和度（saturation）。</p><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>延迟的意思就是服务处理某个请求所需要的时间。这里区分成功请求和失败请求很重要。<br>比如因为数据库连接断开，重新请求导致的超时如果计算入成功请求的统计中，可能会产生误导性的结果。<br><strong>但是，​“慢”错误要比“快”错误更糟！因此，监控错误回复的延迟是很重要的。</strong></p><h3 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h3><p>流量的意思是使用系统中某个高层次指标针对系统负载需求所进行的度量。也就是某一时间内，系统的负载。</p><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误就是字面意思，请求失败的速率。<br>错误分显式失败（浮于表面）和隐式失败（暗埋水底）。<br>在负载均衡器上检测HTTP 500请求可能足够抓住所有的完全失败的请求，但是只有端到端的系统才能检测到返回错误内容（隐式失败或策略原因导致的错误）这种故障类型。</p><h3 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h3><p>饱和度是啥勒，就是服务容量有多“满”。通常是系统中目前最为受限的某种资源的某个具体指标的度量。<br>需要注意的是，很多系统在达到100%利用率之前性能会严重下降，增加一个利用率目标不失为一个好选择。<br><strong>在复杂系统中，饱和度可以配合其他高层次的负载度量来使用：该服务是否可以正常处理两倍的流量，是否可以应对10%的额外流量，或者甚至应对当前更少的流量？对没有请求复杂度变化的简单服务来说（例如，​“返回一个随机数”服务，或者是“返回一个全球唯一的单向递增整数”服务）​，根据负载测试中得到的一个固定数值可能就足够了。</strong><br><strong>延迟增加是饱和度的前导现象。</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果我们度量所有这4个黄金指标，同时在某个指标出现故障时发出警报（或者对于饱和度来说，快要发生故障时）​，能做到这些，服务的监控就基本差不多了。</p><h2 id="关于长尾问题"><a href="#关于长尾问题" class="headerlink" title="关于长尾问题"></a>关于长尾问题</h2><p>在运维（Operations,Ops）领域，“长尾问题”这个概念来源于统计学中的“长尾”理论，该理论最初是在商业和经济学中用来描述某些市场或销售情况的。在运维场景下，长尾问题指的是那些发生频率较低但解决起来可能需要较多资源或时间的问题。<br>长尾问题的特点包括：<br>低频性：这些问题不是经常出现，可能几个月甚至几年才遇到一次。<br>复杂性：由于不常见，因此可能缺乏现成的解决方案或流程来快速有效地解决它们。<br>耗时性：解决这些问题可能会消耗大量的时间和精力，因为需要进行额外的研究或调试。<br>多样性：这类问题往往多种多样，难以预测，每次遇到的情况都可能不同。<br>总结，取平均值会导致系统中的问题不易被发现，分布式分析更合理。</p><h2 id="度量指标时采用合适的精度"><a href="#度量指标时采用合适的精度" class="headerlink" title="度量指标时采用合适的精度"></a>度量指标时采用合适的精度</h2><p>同一系统下的不同部分应该以不同的精度进行度量。<br>没什么是绝对通用的。<br>如果我们的监控目标需要高精度数据，但是却不需要极低的延迟，可以通过一些内部采样机制外部汇总的方式降低成本。</p><h2 id="简化，直到不能再简化"><a href="#简化，直到不能再简化" class="headerlink" title="简化，直到不能再简化"></a>简化，直到不能再简化</h2><p><strong>大道至简</strong><br>复杂是没有止境的。就像任何其他软件系统一样，监控系统可能会变得过于复杂，以至于经常出现问题，变更非常困难，维护起来难度很大。（非常喜欢这句话，贪多嚼不烂）<br>书中给出了几个设计监控系统的原则：<br>1、那些最能反映真实故障的规则应该越简单越好，可预测性强，非常可靠。<br>2、那些不常用的数据收集、汇总，以及警报配置应该定时删除（某些SRE团队的标准是一个季度没有用到一次即将其删除）​。<br>3、收集到的信息，但是没有暴露给任何监控台，或者被任何警报规则使用的应该定时删除。<br>在Google的经验里，指标的收集和汇总，加上警报系统与监控台系统，作为一个相对独立的系统运行是比较好的。​（独立的系统，尽可能简单可靠高效）</p><h2 id="将上述理念结合起来"><a href="#将上述理念结合起来" class="headerlink" title="将上述理念结合起来"></a>将上述理念结合起来</h2><p>本章描述的理念整合起来就成为Google SRE广泛接受和遵循的监控与警报设计哲学。虽然这个设计哲学有一定理想性，但是书写和评审某个新警报时可以依赖的好方法。该哲学同时有助于鼓励团队在解决问题时向正确的方向进行。<br><strong>这里google给出了判断一个监控是否有必要，是否会误判的方法，回答这些问题你会得到自己想要的答案：</strong><br>该规则是否能够检测到一个目前检测不到的、紧急的、有操作性的，并且即将发生或者已经发生的用户可见故障？<br>是否可以忽略这条警报？什么情况可能会导致用户忽略这条警报，如何避免？<br>这条警报是否确实显示了用户正在受到影响？是否存在用户没有受到影响也可以触发这条规则的情况？例如测试环境和系统维护状态下发出的警报是否应该被过滤掉。<br>收到警报后，是否要进行某个操作？是否需要立即执行该操作，还是可以等到第二天早上再进行？该操作是否可以被安全地自动化？该操作的效果是长期的，还是短期的？<br>是否也会有其他人收到相关的紧急警报，这些紧急警报是否是不必要的？<br><strong>以上这些问题其实反映了在应对紧急警报上的一些深层次的理念：</strong><br>每当收到紧急警报时，应该立即需要我进行某种操作。每天只能进入紧急状态几次，太多就会导致“狼来了”效应。<br>每个紧急警报都应该是可以具体操作的。<br>每个紧急警报的回复都应该需要某种智力分析过程。如果某个紧急警报只是需要一个固定的机械动作，那么它就不应该成为紧急警报。<br>每个紧急警报都应该是关于某个新问题的，不应该彼此重叠。<br>从这种角度出发，我们可以得出以下结论：如果某个紧急警报满足上述四点，那么不论是从白盒监控系统还是黑盒监控系统发出都一样。最好多花一些时间监控现象，而不是原因。针对“原因”来说，应该只监控那些非常确定的和非常明确的原因。</p><h2 id="监控系统的长期维护"><a href="#监控系统的长期维护" class="headerlink" title="监控系统的长期维护"></a>监控系统的长期维护</h2><p>随着互联网的高速发展，业务的多变性，敏捷迭代的需求。软件经常重构，负载特性和性能目标也经常变化。现在的某个不常见的、自动化比较困难的警报可能很快就会变成一个经常触发、需要一个临时的脚本来应对的问题。这时，某个人应该去寻找和消除背后的根源问题：如果这种解决办法不可行，那么这条警报的应对就必须要完全自动化。<br>关于监控系统的设计决策应该充分考虑到长期目标。今天发出的每个紧急警报都会占用优化系统的时间，所以经常会牺牲一些短期内的可用性和性能问题，以换取未来系统性能的整体提升。<br>google这里给出了两个案例，感兴趣可以去阅读一下。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>这里直接摘抄书上的小结，我认为分析的非常好。<br>健康的监控和警报系统应该是非常简单、易于理解的。紧急警报应该关注于现象，针对原因的一些启发性分析应该作为调试过程的补充，而不应该进行报警。监控的技术栈层面越高，监控现象越容易，但是监控某些子系统（如数据库）的饱和度和性能参数可能要在该子系统内部直接进行。E-mail警报的价值通常极为有限，很容易变成噪声。我们应该倾向于构建一个良好的监控台页面，直接显示所有的非紧急的异常情况。长远来看，要建立一个成功的on-call轮值体系，以及构建一个稳定的产品需要选择那些正在发生和即将发生的问题来进行报警，设置一个可以实际达到的合理目标，保证监控系统可以支持快速的问题定位与检测。<br><strong>简单可靠高效</strong></p><p><strong>本章完</strong></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE-Google运维解密-第五章减少琐事</title>
    <link href="/2024/08/28/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%87%8F%E5%B0%91%E7%90%90%E4%BA%8B/"/>
    <url>/2024/08/28/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%87%8F%E5%B0%91%E7%90%90%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章更像阐述一种世俗的道理而非技术理论，本篇的思想可以应用在生活中的各个方面。<br><strong>“如果系统正常运转中需要人工干预，应该将此视为一种Bug。”</strong></p><h2 id="琐事的定义"><a href="#琐事的定义" class="headerlink" title="琐事的定义"></a>琐事的定义</h2><p>书中指出，琐事不仅仅代表“我不喜欢做的工作”，在工程任务中或多或少，每个人都会遇到琐事，每个人满意和喜欢的工作内容也是不同的。同时，如管理类的琐事是必须的，这一类被归纳到流程开销中。流程开销通常指与运维工作不直接相关的工作，比如团队会议、目标的建立与评估、日报周报月报等。还有一些是脏活累活，这些脏活累活通常具有长期价值，这些事物也不能算作琐事，比如调整过高的告警，这可能是一件重复性高且繁重的任务，但这不是琐事。<br><strong>那到底什么是琐事？书中指出琐事就是运维服务中手动性的，重复性的，可以被自动化，战术性，没有持久价值的工作。</strong>而且琐事与服务呈线性关系的增长，并不是每件琐事都有以上的全部特性，每件琐事都满意下列一个或多个属性。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="手动性"><a href="#手动性" class="headerlink" title="手动性"></a>手动性</h4><p>例如手动的运行脚本来执行任务，虽然运行一个脚本比手动一步步执行要快，但具体运行脚本所花费的手动时间（不是脚本的运行时间）应该被认为琐事。这里我的理解是自动化运行，定时定期，或者触发性的来运行，比如释放内存。</p><h4 id="重复性"><a href="#重复性" class="headerlink" title="重复性"></a>重复性</h4><p>一件事如果重复做不超过三次，这不能被算作一件琐事。琐事对于重复性的定义是不停反复做的工作，就像打螺丝。如果你是为了解决一个问题而反复进行某场实验，这不能算作琐事。</p><h4 id="可以被自动化的"><a href="#可以被自动化的" class="headerlink" title="可以被自动化的"></a>可以被自动化的</h4><p>如果一件事，计算机可以和人类一样甚至超出人类水平地来完成某个任务，或者通过某种设计变更来彻底消除对某项任务的需求，那么这项任务就是琐事，工作中有非常多这样的琐事，<strong>比如不用DHCP</strong>。如果该项任务的主观判断是必须，那么很大程度上来说，这项任务不属于琐事。（比如流量控制，对于更需要流量的用户分配更高的流量阈值是合理的，但是给领导设置更高的流量阈值嘛，机器是不懂人情世故的。）</p><h4 id="战术性的"><a href="#战术性的" class="headerlink" title="战术性的"></a>战术性的</h4><p>突然的、应对式的工作属于琐事，驱动它们的并非策略或主动安排。处理警报就是琐事，这是无法被避免的工作，但我们必须努力去减少它。</p><h4 id="没有持久价值的"><a href="#没有持久价值的" class="headerlink" title="没有持久价值的"></a>没有持久价值的</h4><p>在完成某一项任务后，服务的状态没有改变，那这就是一件琐事。如果你完成某一项任务，服务得到了改进，它就不是琐事。</p><h4 id="与服务同步线性增长"><a href="#与服务同步线性增长" class="headerlink" title="与服务同步线性增长"></a>与服务同步线性增长</h4><p>书中指出在工作中所设计的任务与服务的大小、流量或用户数量呈线性增长关系，那这项任务可能属于琐事。一个良好管理和设计的服务应该至少可以应对一个数量级的增长，而不需要某些一次性工作（例如增加资源）之外的额外工作。</p><h2 id="为什么琐事越少越好？"><a href="#为什么琐事越少越好？" class="headerlink" title="为什么琐事越少越好？"></a>为什么琐事越少越好？</h2><p>如果琐事不加以控制，它会变得越来越多，以至于迅速占据我们每个人100%的时间。书中指出一个合格的SRE工程师，琐事所占据的工作时间应不超过50%。<br>根据统计，琐事最大的来源是中断性工作（即与服务相关的非紧急的邮件和电子邮件），另一个来源则是on-call（紧急的，值班），紧随其后的是发布和数据更新。<br>在Google SRE工程师中，琐事占用的时间大约在33%。</p><h2 id="什么算作工程工作"><a href="#什么算作工程工作" class="headerlink" title="什么算作工程工作"></a>什么算作工程工作</h2><p>工程工作是一种新颖的、本质上需要主观判断的工作。其符合长期战略，会对你的服务进行长久性的改善的工作。通常具有创新性和创造性，着重通过设计来解决问题，解决方案越通用越好。其有助于运维团队在维持同等人员配置的情况下接受更大或更多的服务。</p><h3 id="常见的工程工作"><a href="#常见的工程工作" class="headerlink" title="常见的工程工作"></a>常见的工程工作</h3><h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><p>编写或修改代码，及其相关设计和文档工作。例：自动化编写脚本，创造工具或框架，增加可扩展性和可靠性的服务功能，或修改基础设施代码以使其更稳健。</p><h4 id="系统工程"><a href="#系统工程" class="headerlink" title="系统工程"></a>系统工程</h4><p>配置生产系统、修改现存配置，或者用一种通过一次性工作产生持久的改进的方法来书写系统文档。例：监控的部署和更新、负载均衡的配置、服务器配置、操作系统的参数调整和负载均衡器的部署。系统工程还包括与研发团队进行的架构、设计和生产环境方面的咨询工作。</p><h4 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h4><p>与运维服务相关的重复性的、手工的劳动。</p><h4 id="流程负担"><a href="#流程负担" class="headerlink" title="流程负担"></a>流程负担</h4><p>与运维服务不直接相关的行政工作。例如招聘、人力资源书面工作、团队&#x2F;公司会议、任务系统的定期清理工作、工作总结、同行评价和自我评价，以及培训课程等。</p><h2 id="琐事繁多是不是一定不好"><a href="#琐事繁多是不是一定不好" class="headerlink" title="琐事繁多是不是一定不好"></a>琐事繁多是不是一定不好</h2><p>琐事虽然会让人不开心，但也不会一直让其不开心，特别是其不太多的情况下。已知和重复的工作让人有一种平静的功效，完成这些事可以带来一种满足和快速胜利感（俗称“割草无双”）。琐事可能是低风险和低压力的活动，有些员工更喜欢做这种事。<br>虽然琐事的存在并不总是坏事，但是它还是会带来如下影响</p><h3 id="职业停滞"><a href="#职业停滞" class="headerlink" title="职业停滞"></a>职业停滞</h3><p>经常做低风险和低压力的活动，甚至是脏活累活，这样并不能得到成长，没有人可以通过不停地做脏活累活满足自己的职业发展。</p><h3 id="士气低落"><a href="#士气低落" class="headerlink" title="士气低落"></a>士气低落</h3><p>每个人对自己可以承担的琐事限度有所不同，但是一定有个限度。过多的琐事会导致过度劳累、厌倦和不满。</p><h3 id="造成误解"><a href="#造成误解" class="headerlink" title="造成误解"></a>造成误解</h3><p>如果个人或者团队过度参与琐事，会破坏这种角色，造成误解。（感觉自己不是运维工程师~）</p><h3 id="进展缓慢"><a href="#进展缓慢" class="headerlink" title="进展缓慢"></a>进展缓慢</h3><p>每个人对自己可以承担的琐事限度有所不同，但是一定有个限度。过多的琐事会导致过度劳累、厌倦和不满。</p><h3 id="开创先例"><a href="#开创先例" class="headerlink" title="开创先例"></a>开创先例</h3><p>如果SRE过于愿意承担琐事，研发同事就更倾向于加入更多的琐事，有时候甚至将本来应该由研发团队承担的运维工作转给SRE来承担。</p><h3 id="促进摩擦产生"><a href="#促进摩擦产生" class="headerlink" title="促进摩擦产生"></a>促进摩擦产生</h3><p>即使你个人对琐事没有怨言，你现在的或未来的队友可能会很不开心。如果团队中引入了太多的琐事，其实就是在鼓励团队里最好的工程师开始寻找其他地方提供的更有价值的工作。</p><h3 id="违反承诺"><a href="#违反承诺" class="headerlink" title="违反承诺"></a>违反承诺</h3><p>那些为了项目工程工作而新入职的员工，以及转入SRE的老员工会有被欺骗的感觉，这非常不利于公司的士气。（感觉自己不是运维工程师~）</p><p><strong>本章完</strong></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRE:Google运维解密_第四章服务质量目标</title>
    <link href="/2024/08/16/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87/"/>
    <url>/2024/08/16/SRE-Google%E8%BF%90%E7%BB%B4%E8%A7%A3%E5%AF%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对SRE感兴趣是因为我的实习工作，工作中内部文档给我所带来的技术视野提升让我意识到不能止步于传统的网络技术，技术跟随时代一起前进，我也不能被落下。</p><h2 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h2><p>这里就不讲SRE的概念了，感兴趣的可以自己去搜集资料，SRE是devops这个概念的前身。</p><h2 id="为什么选择这本书？"><a href="#为什么选择这本书？" class="headerlink" title="为什么选择这本书？"></a>为什么选择这本书？</h2><p>Google作为一家为全球提供网络服务的公司，其网络所承载的数据量极大，在技术领域一直处在世界领先位置，跟着领头羊走准没错。不过该书中一些产品及技术均为谷歌自研，参考意义不大，更多的是学习其思路和扩展技术视野。</p><h2 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h2><p>这个概念在系统中非常重要，没有服务质量，不去度量这些行为的正确性，就无法正确的运维一个系统。<br>书中提到了三个有关服务质量的概念，分别是服务质量指标（SLI）、服务质量目标（SLO）以及服务质量协议（SLA）。<br><strong>这三项指标分别是指向服务或系统内最为重要的基础指标、指标的预期值以及当不满足预期时的应对计划。</strong><br>事先确定合适的指标有助于运维发现风险、解决风险。</p><h3 id="服务质量术语"><a href="#服务质量术语" class="headerlink" title="服务质量术语"></a>服务质量术语</h3><p>SLA、SLI、SLO这三者概念其实我都不是很清楚，正好借此机会好好梳理一番。</p><h4 id="服务质量指标SLI"><a href="#服务质量指标SLI" class="headerlink" title="服务质量指标SLI"></a>服务质量指标SLI</h4><p>SLI是指某一服务的某项服务质量下一个具体量化指标<br>举一个例子，比如响应时间，99%的用户请求在200ms内响应。<br>书中提出SLI一般都是通过汇总：在某一个度量时间范围内将原始数据收集起来，计算速率、平均值、百分比等汇总数据。<br>书中指出在理想状态下，SLI应该直接度量某一个具体的服务质量。当然，这是不可能的，不然就没有另外两个指标概念了。<br><strong>在很多情况下，直接的度量信息可能非常难以获取，或者无法被观测，只能抽象的使用某种指标替代。</strong><br>这里举一个书中的例子，比如客户端的延迟通常是最直接的用户指标，但是由于条件限制或其他因素，只能监控服务端的延迟数据。</p><p>另一个被重视的SLI指标是可用性，其代表了服务可用时间的百分比，该指标通常利用“格式正确的请求成功处理的比例”来定义。也会被成为服务产出。<br>在存储系统中，持久性也是一个重要的SLI指标，持久性是指一组数据能够完整保存的时间。100%的“可用性”、“持久性”是不可能实现的，只能以接近100%的指标作为一个未来实现的目标，行业内也经常用9的数量来描述可用程序，目前Google云计算服务公开的可用性指标是“3.5个9”–99.95%可用。</p><h4 id="服务质量目标SLO"><a href="#服务质量目标SLO" class="headerlink" title="服务质量目标SLO"></a>服务质量目标SLO</h4><p>SLO是指服务某个SLI的目标值，或者目标范围。<br>SLO的定义是SLI&lt;&#x3D;目标值，或者范围下限&lt;&#x3D;SLI&lt;&#x3D;范围上限。<br>比如你打游戏，游戏的延迟就不能太高，不然就会很卡。对游戏延迟的这个预期就是一种SLO。<br>本书中提到了莎士比亚搜索服务，并以此举例，感兴趣的可以去原书阅读。<br>书中指出选择一个合适的SLO是非常复杂的过程，影响其的因素众多，比如无法确定一个具体的值，书中提出了一个例子，比如外部传入的HTTP请求，其每秒查询数量（QPS）指标是由用户决定的，用户可以刷新或多次查询，这样会导致一个用户传出多个请求，从而无法正确的设置一个SLO。<br>书中也指出，虽然无法这样确定一个SLO，但可以通过其他的角度来看待，比如通过指定平均请求的延迟。<br>这两个SLI，QPS和延迟两者是很可能相关联的：QPS的升高通常会导致延迟升高，服务到达一定负载水平后性能下降是常见的。</p><p>通过设立SLO，可以帮助设立用户对服务质量的预期，避免用户抱怨“服务太慢了”。如果没有该指标，用户就会按照自己的想法设置一个SLO，这个SLO不一定具有合理性，导致其错误的认为这个更可靠或更不可靠。</p><p>阅读到这里，书中给出了一个真实的例子，全球Chubby服务计划内停机，具体细节请自行查阅。大致内容是Chubby是一个被众多系统所依赖的服务，其有一个预期的SLO，如果该季度没有达到，Google的SRE工程师通过计划内停止提供该服务来使系统不那么依赖该服务，对其可靠性有更明确的认知。</p><h4 id="服务质量协议SLA"><a href="#服务质量协议SLA" class="headerlink" title="服务质量协议SLA"></a>服务质量协议SLA</h4><p>SLA指服务与用户之间一个明确的，或者不明确的协议，讲述了在达到或者没有达到SLO之后的后果。这些后果可以是财务方面的，也可能是其他类型的，具体由服务和用户之间协定。<br>看起来SLA和SLO有些类似，怎么区别它们呢？<br>“如果SLO没有打到时，有什么后果”如果没有明确的后果，那么就是一个SLO，而非SLA。</p><p>通常来说，SRE工程师不会参与到SLA的书写，因为SLA是与业务产品决策息息相关的，SRE工程师通常是作为辅助为参与者提供帮助，避免触发SLA中的惩罚性条款，同时参与定义具体的SLI。</p><p>举一个例子，比如Google的搜索服务是否可用或Google的工作流系列软件，不管某个服务是否具有SLA，定义SLI与SLO，并且用它们来管理服务质量都是很有价值的。</p><h2 id="指标在实践中的应用"><a href="#指标在实践中的应用" class="headerlink" title="指标在实践中的应用"></a>指标在实践中的应用</h2><p>在前面，我们讲述了有关服务质量的一些概念，讲述了为什么合适的指标对于服务质量来说这么重要，接下来是如何判断哪些指标对服务是最重要的。</p><h3 id="运维人员和最终用户各关心什么？"><a href="#运维人员和最终用户各关心什么？" class="headerlink" title="运维人员和最终用户各关心什么？"></a>运维人员和最终用户各关心什么？</h3><p>首先，不是监控系统中的所有数据都可以被定义为SLI；只有理解用户对系统的真实需求，才能决定哪些数据是否有用。过多的设立指标会减少那些对系统真正重要的指标的关注，过少的指标则会导致某些重要的系统行为被忽略。书中建议，四到五个具有代表性的指标对系统监控程序的评估和关注就足够了。<br>书中将常见的SLI分为以下几大类：<br>用户可见的系统服务：通常是可用性、延迟以及吞吐量，换种说法，是否能正常处理请求？每个请求花费的时间是多少？多少的请求可以被处理？<br>存储系统的通常强调：通常是延迟、可用性以及持久性。读写数据需要的时间，是否可以随时访问数据，数据经过一段时间是否能被正常的读取。<br>大数据系统：这类系统通常是数据处理流水线系统，通常关注吞吐量和端到端的延迟。处理了多少数据？数据从输入到产出需要多少时间？<br>系统正确性：这是所有系统都应该关注的，只有返回一个正确的回复，正确的过程，这才是一个正确的系统。正确性是衡量系统健康程度的一个重要指标，但是其更关注系统内部的数据，而不是系统本身，通常这不是SRE直接负责的。</p><h3 id="如何收集指标"><a href="#如何收集指标" class="headerlink" title="如何收集指标"></a>如何收集指标</h3><p>利用某种监控系统，比如zabbix、Prometheus，大部分的指标数据都在服务器端被收集。也可以利用一些日志分析系统，分析日志中某种状态码回复所占的比例。当然，也有一些系统可以加入到客户端数据的收集，可以收集到一些不影响服务器端，但是能对用户产生影响的问题。<br>书中还是拿莎士比亚搜索系统举例，过于关注莎士比亚服务器搜索后端延迟可能会导致错失页面JS脚本导致的用户可见的延迟问题，在这个例子中，度量页面在浏览器中可用的延迟是度量用户体验的一个更好的指标。</p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>监控数据通常是庞大的，我们需要通过一些手段来简化使数据可用，汇总是手段的一种，汇总的过程应该非常小心。<br>对待一些简单的指标也不要掉以轻心，大部分指标都应该以“分布”，而不是平均值来定义。<br>响应时间的分布的分散程度与用户受到长尾请求延迟的影响关联性较高，这可能预示了负载过高情况下出现的排队问题。<br>书中指出，经研究显示，用户更喜欢速度较慢但是更稳定的系统，而不是一个请求速度抖动很厉害的系统。<br>经过上述结论，某些SRE团队只关注长尾部分，因为如果99.9%的系统行为都正常的话，那50%部分就肯定也是正常的。<br><strong>注：长尾部分在监控数据中代表了异常值或极端值，这些数据点虽然数量较少，但往往具有重要的意义。通过识别和分析长尾部分，可以发现并解决潜在的问题，从而提高系统的稳定性和用户体验。</strong><br>书中还讨论了为什么采取分布式而不是平均值的方式，这里不过多赘述，感兴趣可以自行阅读。</p><h3 id="指标的标准化"><a href="#指标的标准化" class="headerlink" title="指标的标准化"></a>指标的标准化</h3><p>书中提到指标的标准化，通过制作标准化模板来避免重复的操作，减轻工作量。</p><h2 id="目标在实践中的应用"><a href="#目标在实践中的应用" class="headerlink" title="目标在实践中的应用"></a>目标在实践中的应用</h2><p>书中指出，度量用户真正关心的部分是非常难，甚至不可实现的。所以需要通过某种近似的方法，与其选择指标，再想出对应的目标，不如从想要的目标反向推导出具体的指标。</p><h3 id="目标的定义"><a href="#目标的定义" class="headerlink" title="目标的定义"></a>目标的定义</h3><p>为了更清晰地定义，SLO应该具体指出它们是如何被度量的，以及其有效条件。<br>如果某个SLI很重要，也可以指定多个SLO目标。<br>要求SLO能够被100%满足是不正确，也是不显示的，过于强调则会降低创新和部署的速度，增加成本，损失创造性。<br>书中给出了一个更好的办法，使用错误预算（Error Budget）。对达不到SLO的容忍度，以时间单位计量对其评估，概括一下就是SLO的SLO。<br>通过周期性的监控SLO达标程度可以展示一个趋势，这样就可以在重大问题发生之前得到预警。<br>书中指出SLO不达标的频率可以用来与错误预算进行对比，利用这两个数值的差值可以指导新版本的发布。</p><h3 id="目标的选择"><a href="#目标的选择" class="headerlink" title="目标的选择"></a>目标的选择</h3><p>设置SLO不是一个单纯的技术活动，设计到产品和业务层面的决策。有些时候需要考虑到各个方面，做出一些放弃的决策。<br>书中给出了一些建议<br><strong>不要仅以目前的状态为基础选择目标</strong><br>要从全局考虑，避免团队被迫长期运维一个过时的系统。<br><strong>保持简单</strong><br>复杂的系统往往会掩盖系统的一些变化，同时也更难以理解。<br><strong>避免绝对值</strong><br>绝对值在系统设计中是不切实际的，即使有一种系统能达到这种要求，所付出的代价也是不可估量的，也比用户所需的高出许多。<br><strong>SLO越少越好</strong><br>SLO必须精准，尽量精简，抛弃不必要的SLO。<br><strong>不要追求完美</strong><br>追求完美往往会陷入一个不可走出的怪圈，可以从一个松散的目标开始，再逐步优化缩紧，这比一开始制定一个困难的计划，并执行容易的多。<br>好的SLO对团队有益，但是一个没有精心调校的SLO会导致浪费。</p><h2 id="控制手段"><a href="#控制手段" class="headerlink" title="控制手段"></a>控制手段</h2><p>通过SLI和SLO在决策系统运维时非常有用<br>举例，某个系统服务在一个时间段内延迟持续上涨，通过SLI及SLO判断，进行操作，解决风险。</p><h3 id="SLO建立用户预期"><a href="#SLO建立用户预期" class="headerlink" title="SLO建立用户预期"></a>SLO建立用户预期</h3><p>通过公布SLO可以使用户得到对系统行为的预期，以理解该服务是否能够满足他们的要求。<br>为了让用户拥有一个正确的预期，书中提出可以考虑以下几种策略：<br><strong>留出一定安全空间</strong><br>留出冗余，响应并解决问题。<br><strong>实际SLO也不要过高</strong><br>避免用户因冗余产生依赖，参考前面Chubby服务。</p><h2 id="协议在实践中的应用"><a href="#协议在实践中的应用" class="headerlink" title="协议在实践中的应用"></a>协议在实践中的应用</h2><p>起草一份SLA通常是业务部门和法务部门共同努力的结果，SRE在这之中作为以一个辅助者的角色来工作。帮助这些部门理解SLA的SLO达标率和困难程度。</p><p><strong>本章完</strong></p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>SRE</tag>
      
      <tag>google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_3</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-3/</url>
    
    <content type="html"><![CDATA[<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><p>镜像是Docker的三大组件之一。<br><strong>运行容器前需要本地存在对应的镜像，如果本地不存在，则会从镜像仓库拉取镜像。</strong></p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"># 从Docker镜像仓库获取镜像<br>$ docker pull <span class="hljs-comment">[选项]</span> <span class="hljs-comment">[Docker Registry 地址<span class="hljs-comment">[:端口号]</span>/]</span>仓库名<span class="hljs-comment">[:标签]</span><br></code></pre></td></tr></table></figure><p>可能会出现的问题：命令仅支持小写<br>当前用户没有权限访问Docker守护进程<br>使用sudo提升权限，或者将用户加入Docker用户组</p><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看本地镜像</span><br>docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><strong>这个列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。</strong><br>前面提到过仓库和标签的概念，这里需要讲一下镜像ID的概念，就好比身份证这是唯一标识，一个镜像是可以对应多个标签。</p><p>当你查看本地镜像，你肯定会为其的体积之小感到惊讶。对比完整镜像系统动辄数G的大小，几十M的镜像文件有些不可思议。首先Docker上的镜像本身就是极简版，同时因为复用机制的存在，所以能如此高效。<br>真的是极简，vi都没有。<br>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 63.3MB，但是在 Docker Hub 显示的却是 25.47 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。<br>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。<br>你可以通过 docker system df 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:20.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 执行运行容器命令</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--rm ubuntu:20.04 bash</span><br></code></pre></td></tr></table></figure><p>这里讲一下各参数<br>-i： 使容器保持标准输入处于打开状态，即使没有连接终端。<br>-t： 分配一个伪TTY（终端），让你可以与容器进行交互。<br>–rm： 在容器退出时自动删除容器。这个选项确保容器在使用完毕后不会留在系统中，占用存储空间。  默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动docker rm。<br>ubuntu:20.04: 这是要使用的镜像和标签，表示基于ubuntu:20.04镜像创建容器。<br>bash: 这是在容器中要运行的命令。在这里，指定了bash，表示启动容器后，运行bash命令，使你进入容器的交互式终端。  </p><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p><strong>在镜像中，有一个特殊的镜像，其没有仓库名，也没有标签，均为none。</strong><br>这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 none。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 none 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#查找虚悬镜像</span><br>$ docker image ls -f <span class="hljs-attr">dangling=</span><span class="hljs-literal">true</span><br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br><span class="hljs-tag">&lt;none&gt;</span>              <span class="hljs-tag">&lt;none&gt;</span>              <span class="hljs-number">00285</span>df0df87        <span class="hljs-number">5</span> days ago          <span class="hljs-number">342</span> MB<br></code></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment">#删除悬空镜像</span><br><span class="hljs-variable">$ </span>docker image prune<br></code></pre></td></tr></table></figure><h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了<strong>加速镜像构建、重复利用资源</strong>，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#查看所有镜像，添加参数-a</span><br><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><p>不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。<br>根据仓库名列出镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#指定仓库名，查询仓库下的所有tag</span><br>$ docker image ls ubuntu<br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>ubuntu              <span class="hljs-number">18.04</span>               <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br>ubuntu              bionic              <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br></code></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#指定仓库名和标签，查询某个镜像</span><br>$ docker image ls ubuntu:<span class="hljs-number">18.04</span><br>REPOSITORY          <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>ubuntu              <span class="hljs-number">18.04</span>               <span class="hljs-number">329</span>ed837d508        <span class="hljs-number">3</span> days ago          <span class="hljs-number">63.3M</span>B<br></code></pre></td></tr></table></figure><p>除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#通过过滤器参数查找指定镜像</span><br>$ docker image ls -f since=mongo:3.2<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>redis               latest              5f515359c7f8       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 183 </span>MB<br>nginx               latest              05a60462f8ba       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 181 </span>MB<br></code></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。<br>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#举例</span><br><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <span class="hljs-operator">-f</span> label=com.example.version=<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2><p><strong>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。</strong>比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ docker image ls -q<br><span class="hljs-number">5</span>f5<span class="hljs-number">15359c7f8</span><br><span class="hljs-number">05</span>a60462f8ba<br>fe<span class="hljs-number">9198c04d62</span><br><span class="hljs-number">00285d</span>f0df87<br><span class="hljs-number">329</span>ed<span class="hljs-number">837d508</span><br><span class="hljs-number">329</span>ed<span class="hljs-number">837d508</span><br></code></pre></td></tr></table></figure><p>–filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。<br>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。<br>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">ls</span> <span class="hljs-string">--format</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123;.ID&#125;&#125;</span>: <span class="hljs-template-variable">&#123;&#123;.Repository&#125;&#125;</span>&quot;</span><br><span class="hljs-attr">5f515359c7f8:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">05a60462f8ba:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">fe9198c04d62:</span> <span class="hljs-string">mongo</span><br><span class="hljs-attr">00285df0df87:</span> <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span><br><span class="hljs-attr">329ed837d508:</span> <span class="hljs-string">ubuntu</span><br></code></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker image ls --format &quot;table </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ID</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Repository</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Tag</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br><span class="language-xml">IMAGE ID            REPOSITORY          TAG</span><br><span class="language-xml">5f515359c7f8        redis               latest</span><br><span class="language-xml">05a60462f8ba        nginx               latest</span><br><span class="language-xml">fe9198c04d62        mongo               3.2</span><br><span class="language-xml">00285df0df87        <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span></span><br><span class="language-xml">329ed837d508        ubuntu              18.04</span><br><span class="language-xml">329ed837d508        ubuntu              bionic</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_2_补充</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2-%E8%A1%A5%E5%85%85/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2-%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="配置Docker镜像源加速"><a href="#配置Docker镜像源加速" class="headerlink" title="配置Docker镜像源加速"></a>配置Docker镜像源加速</h1><p>因为不可抗因素，在国内Docker从仓库上pull镜像下来比较麻烦。<br>这里提供一个解决该问题的方法，配置镜像源加速。</p><p>可用系统：Ubuntu、Debian、CentOS<br>目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。</p><p>请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\-\-registry\-mirror&#x27;</span><br></code></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 $ systemctl cat docker 查看 ExecStart&#x3D; 出现的位置，修改对应的文件内容去掉 –registry-mirror 参数及其值，并按接下来的步骤进行配置。<br>如果以上命令没有任何输出，那么就可以在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>阿里镜像加速器<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?spm=a2c6h.12873639.article-detail.16.21cc12deEEPYCT">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?spm=a2c6h.12873639.article-detail.16.21cc12deEEPYCT</a></p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_2</title>
    <link href="/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/"/>
    <url>/2024/08/15/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>系统：Ubuntu 22.04 LTS </p><h3 id="确保下载源安全性："><a href="#确保下载源安全性：" class="headerlink" title="确保下载源安全性："></a>确保下载源安全性：</h3><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># 添加使用HTTPS传输的软件包以及CA证书</span><br>$ sudo apt-get update<br><br>$ sudo apt-get install <span class="hljs-string">\</span><br>    apt-transport-https <span class="hljs-string">\</span><br>    ca-certificates <span class="hljs-string">\</span><br>    curl <span class="hljs-string">\</span><br>    gnupg <span class="hljs-string">\</span><br>    lsb-release<br></code></pre></td></tr></table></figure><h3 id="鉴于国内网络问题，修改为镜像源为国内源："><a href="#鉴于国内网络问题，修改为镜像源为国内源：" class="headerlink" title="鉴于国内网络问题，修改为镜像源为国内源："></a>鉴于国内网络问题，修改为镜像源为国内源：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 添加阿里源及软件源的GPG密钥</span><br>$ curl -fsSL https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/ubuntu/g</span>pg | sudo gpg --dearmor -o <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/keyrings/</span>docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">向 sources.list 中添加 Docker 软件源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure><h3 id="更新apt软件包缓存："><a href="#更新apt软件包缓存：" class="headerlink" title="更新apt软件包缓存："></a>更新apt软件包缓存：</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h3 id="安装Docker-ce："><a href="#安装Docker-ce：" class="headerlink" title="安装Docker-ce："></a>安装Docker-ce：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sudo apt-<span class="hljs-built_in">get</span> install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><h3 id="启动Docker："><a href="#启动Docker：" class="headerlink" title="启动Docker："></a>启动Docker：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl start docker</span><br></code></pre></td></tr></table></figure><h3 id="建立Docker用户组："><a href="#建立Docker用户组：" class="headerlink" title="建立Docker用户组："></a>建立Docker用户组：</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><h3 id="建立-docker-组："><a href="#建立-docker-组：" class="headerlink" title="建立 docker 组："></a>建立 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> groupadd docker</span><br></code></pre></td></tr></table></figure><h3 id="将当前用户加入-docker-组："><a href="#将当前用户加入-docker-组：" class="headerlink" title="将当前用户加入 docker 组："></a>将当前用户加入 docker 组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span></span><br></code></pre></td></tr></table></figure><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ docker run <span class="hljs-comment">--rm hello-world</span><br><br>Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally<br>latest: Pulling <span class="hljs-built_in">from</span> library/hello-world<br>b8dfde127a29: Pull complete<br>Digest: sha256:<span class="hljs-number">308866</span>a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello <span class="hljs-built_in">from</span> Docker!<br>This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.<br><br>To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:<br> <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.<br> <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">&quot;hello-world&quot;</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.<br>    (amd64)<br> <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span><br>    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.<br> <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span><br>    <span class="hljs-built_in">to</span> your terminal.<br><br>To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:<br> $ docker run -<span class="hljs-keyword">it</span> ubuntu bash<br><br>Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:<br> <span class="hljs-keyword">https</span>://hub.docker.com/<br><br>For more examples <span class="hljs-keyword">and</span> ideas, visit:<br> <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/<br></code></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习记录_1</title>
    <link href="/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/12/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）:"></a>镜像（image）:</h3><p>众所周知，操作系统分为内核和用户空间（linux系统一切皆文件）。内核启动后，会挂载root文件系统为其提供用户空间支持。Docker的镜像，就相当于是一个root文件系统。<br>分层存储的概念：<br>镜像本身包含完整的root文件，体积往往是庞大的。Docker为了解决这种问题，在设计时充分利用Union Fs技术，将其设计为分层存储的架构。（ 因为多个镜像可以共享相同的基础层。例如，如果你有多个基于同一操作系统的镜像，这些镜像就可以共享这个操作系统层。）<br>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<br>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h4 id="简单比喻"><a href="#简单比喻" class="headerlink" title="简单比喻"></a>简单比喻</h4><p>可以把 Docker 镜像想象成一本书：<br>● 基础镜像 是书的第一个版本，只读的。<br>● 应用层 是你在第一个版本上增加的注释，还是只读的。<br>● 配置层 是你在前面的基础上又增加的更多注释，仍然只读。<br>● 容器 是你从这本书的最后一个版本上复印了一份，你可以在上面随便写东西（可写层）。<br>这个过程节省了很多纸张（空间），因为你的注释（修改）只是增加了几页，而不是重新写了一本书。</p><h2 id="容器（container）："><a href="#容器（container）：" class="headerlink" title="容器（container）："></a>容器（container）：</h2><p>镜像和容器之间的关系，就像面向对象中的类和实例一样。（类是一种模板，定义了对象属性和行为，它不真实存在。实例是根据类创建的具体对象，它具备类的属性和行为，并且真实存在。）<br>打个比方，车是一个类，具体到实例就是什么车，什么颜色，什么发动机等。<br>容器的实质是进程，但与在宿主机直接执行的进程不同，容器的进程有自己独立的命名空间。正因如此，容器可以拥有自己的root文件系统，各项配置都是独立的。容器内的进程是运行在一个隔离的环境里，使用起来就像一个独立的操作系统一样。这种特性借鉴了沙箱，也使得容器封装的应用比直接运行在宿主机更加安全。</p><p>容器与虚拟机之间的区别，虚拟机是一个完整的操作系统，而容器只是一个运行在宿主机上，拥有独立命令空间的进程。<br>● 虚拟机：提供完整的操作系统环境，资源开销大，启动慢，但隔离性强，适用于需要高度隔离和安全的场景。<br>● 容器：共享操作系统内核，资源开销小，启动快，但隔离性相对较弱，适用于轻量级、快速部署和需要高密度计算的场景。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id="Docker中的镜像和容器"><a href="#Docker中的镜像和容器" class="headerlink" title="Docker中的镜像和容器"></a>Docker中的镜像和容器</h3><p>● 镜像（Image）：镜像就像类，是一个模板，定义了应用程序及其运行环境的所有内容。它是一个只读的文件系统层，用于创建容器。<br>● 容器（Container）：容器就像实例，是镜像的一个具体实现。它是一个运行时的实例，具有镜像的所有特性，并且可以进行实际操作和修改。</p><h2 id="仓库（repository）："><a href="#仓库（repository）：" class="headerlink" title="仓库（repository）："></a>仓库（repository）：</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><h3 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h3><p>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder&#x2F;nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-服务："><a href="#Docker-Registry-服务：" class="headerlink" title="Docker Registry 服务："></a>Docker Registry 服务：</h3><p>公有：<br>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。<br>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。除此以外，还有 Red Hat 的 Quay.io；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务；代码托管平台 GitHub 推出的 ghcr.io。<br>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。<br>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。<br>私有：<br>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。<br>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。<br>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="Docker对比传统虚拟化有什么优势？"><a href="#Docker对比传统虚拟化有什么优势？" class="headerlink" title="Docker对比传统虚拟化有什么优势？"></a>Docker对比传统虚拟化有什么优势？</h2><p>Docker相较于传统虚拟化相比有以下优势</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><p>特性        容器            虚拟机<br>启动        秒级            分钟级<br>硬盘使用    一般为 MB        一般为 GB<br>性能        接近原生        弱于<br>系统支持量    单机支持上千个容器 一般几十个</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>基础IT架构</tag>
      
      <tag>虚拟化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zabbix学习记录_1</title>
    <link href="/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/"/>
    <url>/2024/08/11/zabbix%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是zabbix？"><a href="#什么是zabbix？" class="headerlink" title="什么是zabbix？"></a>什么是zabbix？</h2><p>zabbix是一个监控软件，其可以监控各种网络参数，保证企业服务架构安全运营，同时支持灵活的告警机制，可以使得运维人员快速定位故障、解决问题。zabbix支持分布式功能，支持复杂架构下的监控解决方案，也支持web页面，为主机监控提供了良好直观的展现。<br>zabbix官网地址为<a href="https://www.zabbix.com/">https://www.zabbix.com/</a></p><h2 id="zabbix组成"><a href="#zabbix组成" class="headerlink" title="zabbix组成"></a>zabbix组成</h2><h3 id="zabbix-server"><a href="#zabbix-server" class="headerlink" title="zabbix server"></a>zabbix server</h3><p>概念：核心组件，内部存储了所有的配置信息、统计信息和操作信息。zabbix agent会向zabbix server报告可用性、完整性及其他统计信息。</p><h3 id="web页面"><a href="#web页面" class="headerlink" title="web页面"></a>web页面</h3><p>web页面属于zabbix的一部分，通过图形化界面直观展示了监控信息，方便运维人员监控管理。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>zabbix使用数据库，存储监控数据。</p><h3 id="zabbix-proxy"><a href="#zabbix-proxy" class="headerlink" title="zabbix proxy"></a>zabbix proxy</h3><p>这里不得不说到zabbix的三种部署方式，server-client，server-proxy-client，server-node-client，在不同网络架构下部署不同的模式，具体差别请自行搜索，这里不再赘述。<br>zabbix proxy可以根据具体生产环境进行采用或者放弃。如果使用了zabbix proxy，则其会替代zabbix server采集数据信息，可以很好的分担zabbix server的负载。zabbix proxy通常运用与架构过大、zabbix server负载过重，或者是企业设备跨机房、跨网段、zabbix server无法与zabbix agent直接通信的场景。</p><h3 id="zabbix-Agent"><a href="#zabbix-Agent" class="headerlink" title="zabbix Agent"></a>zabbix Agent</h3><p>zabbix agent通常部署在被监控目标上，用于主动监控本地资源和应用程序，并将监控的数据发送给zabbix server。</p><h2 id="zabbix是怎样工作的？"><a href="#zabbix是怎样工作的？" class="headerlink" title="zabbix是怎样工作的？"></a>zabbix是怎样工作的？</h2><p>zabbix在进行监控时，agent作为zabbix客户端被安装在被监控设备上，负责定期收集数据并将其转发给zabbix服务端，服务端的主要工作是存储数据及提供web服务。<br>zabbix的数据收集分为两种模式：</p><h3 id="1、主动"><a href="#1、主动" class="headerlink" title="1、主动"></a>1、主动</h3><p>客户端主动向服务端请求监控项列表，并主动将收集到的数据提交给服务端。</p><h3 id="2、被动"><a href="#2、被动" class="headerlink" title="2、被动"></a>2、被动</h3><p>由服务端向客户端发起请求监控项列表，随后客户端返回信息到服务端。</p><p>主被关系均以zabbix客户端为基准</p><h2 id="zabbix的工作进程有哪些？"><a href="#zabbix的工作进程有哪些？" class="headerlink" title="zabbix的工作进程有哪些？"></a>zabbix的工作进程有哪些？</h2><p>在默认的情况下，zabbix有6个工作进程；分别是 zabbix_agentd，zabbix_get，zabbix_proxy，zabbix_sender，zabbix_server 和 zabbix_gateway。<br>其中，zabbix_java_gateway是可选进程。（监控JMX虚拟机）</p><h3 id="1、zabbix-agentd"><a href="#1、zabbix-agentd" class="headerlink" title="1、zabbix_agentd"></a>1、zabbix_agentd</h3><p>zabbix-agentd为zabbix客户端守护进程 ，主要负责收集客户端监控项数据。</p><h3 id="2、zabbix-server"><a href="#2、zabbix-server" class="headerlink" title="2、zabbix_server"></a>2、zabbix_server</h3><p>zabbix_server为zabbix服务端守护进程，主要负责收集zabbix客户端数据。（端口为10051）（固定端口吗？）</p><h3 id="3、zabbix-proxy"><a href="#3、zabbix-proxy" class="headerlink" title="3、zabbix_proxy"></a>3、zabbix_proxy</h3><p>zabbix_proxy是zabbix的代理程序，其功能类似于server，作用上类似于一个中转站，最终会把收集的数据再次提交给zabbix_server。</p><h3 id="4、zabbix-get"><a href="#4、zabbix-get" class="headerlink" title="4、zabbix_get"></a>4、zabbix_get</h3><p>zabbix_get作为zabbix工具，通常运行在zabbix_server或者zabbix_proxy上，用于远程获取客户端信息，通常用于排错。</p><h3 id="5、zabbix-sender"><a href="#5、zabbix-sender" class="headerlink" title="5、zabbix_sender"></a>5、zabbix_sender</h3><p>zabbix_sender也是zabbix的一个工具，通常运行在zabbix的客户端，用于耗时比较长的检查，其作用是主动发送数据。</p><h3 id="6、zabbix-java-gateway"><a href="#6、zabbix-java-gateway" class="headerlink" title="6、zabbix_java_gateway"></a>6、zabbix_java_gateway</h3><p>zabbix_java_gateway是zabbix2.0以后引入的新功能，可以用于JAVA方面的设备；但是只能主动获取数据，而不能被动获取数据。</p><h2 id="zabbix具体能有哪些监控？"><a href="#zabbix具体能有哪些监控？" class="headerlink" title="zabbix具体能有哪些监控？"></a>zabbix具体能有哪些监控？</h2><p>硬件监控：通过IPMI接口进行监控，监控对象的物理特征，如电压、温度、风扇状态、电源状态等<br>系统监控：zabbix agent interface，通过专用的代理程序进行监控，与常见的master&#x2F;agent模式类似，如果被监控对象支持对应的agent，推荐首选这种模式<br>java监控：zabbix JMX interface，通过JMX进行监控，JMX(java扩展管理)，通常用于监控JVM虚拟机<br>网络设备监控：zabbix snmp interface，通过snmp协议与被监控对象进行通信，通常来讲，无法在如路由器，交换机这种网络设备上安装agent，但是这些设备通常都支持snmp协议<br>应用服务监控、MYSQL数据库监控、URL监控<br>网络设备监控，系统监控，硬件监控为重点。</p><h2 id="zabbix的常用术语"><a href="#zabbix的常用术语" class="headerlink" title="zabbix的常用术语"></a>zabbix的常用术语</h2><h3 id="1、主机（host）"><a href="#1、主机（host）" class="headerlink" title="1、主机（host）"></a>1、主机（host）</h3><p>要监控的设备，可以由IP或者是主机名（必须可解析）指定。</p><h3 id="2、主机组（host-group）"><a href="#2、主机组（host-group）" class="headerlink" title="2、主机组（host group）"></a>2、主机组（host group）</h3><p>主机的逻辑容器，包含主机和模板，主机组通常在给用户或者是用户组指派监控权限时使用。</p><h3 id="3、监控项（item）"><a href="#3、监控项（item）" class="headerlink" title="3、监控项（item）"></a>3、监控项（item）</h3><p>一个特定监控指标的相关数据，比如内存的大小、CPU的使用率，甚至是服务的运行状态等等。监控项数据来源于被监控对象，并且每个监控项都由一个key来标识。</p><h3 id="4、触发器（trigger）"><a href="#4、触发器（trigger）" class="headerlink" title="4、触发器（trigger）"></a>4、触发器（trigger）</h3><p>一个表达式，用于评估监控项的值是否在合理的范围内。当接收的值超出触发器的规定时，就被认为是故障，如果超出后再次符合，就被认为是正常，也就意味着这是一个过程，it运维小分队里的告警机器人用的就是该项。</p><h3 id="5、事件（event）"><a href="#5、事件（event）" class="headerlink" title="5、事件（event）"></a>5、事件（event）</h3><p>触发器触发的一个特定事件，或者是zabbix定义的一个自动上线注册主机的事件。</p><h3 id="6、动作（action）"><a href="#6、动作（action）" class="headerlink" title="6、动作（action）"></a>6、动作（action）</h3><p>指根据配置，zabbix对于触发器触发的特定事件进行处理的具体措施，如执行某个脚本，或者是向管理员邮箱发送邮件等等。</p><h3 id="7、报警升级（escalation）"><a href="#7、报警升级（escalation）" class="headerlink" title="7、报警升级（escalation）"></a>7、报警升级（escalation）</h3><p>发送警报或者是执行远程命令的自定义方案。</p><h3 id="8、媒介（media）"><a href="#8、媒介（media）" class="headerlink" title="8、媒介（media）"></a>8、媒介（media）</h3><p>发送通知（告警）的手段，如微信、邮件、钉钉等等。</p><h3 id="9、通知（notification）"><a href="#9、通知（notification）" class="headerlink" title="9、通知（notification）"></a>9、通知（notification）</h3><p>通过指定的媒介，向用户发送的有关事件的信息。</p><h3 id="10、远程命令（remote-command）"><a href="#10、远程命令（remote-command）" class="headerlink" title="10、远程命令（remote command）"></a>10、远程命令（remote command）</h3><p>指运维人员提前写好的命令，可以让被监控主机在触发事件后执行。</p><h3 id="11、模板（template）"><a href="#11、模板（template）" class="headerlink" title="11、模板（template）"></a>11、模板（template）</h3><p>用于快速定义被监控主机的预设条目集合，通常包括了监控项、触发器、应用等，模板可以直接链接至某个主机。</p><h3 id="12、应用（application）"><a href="#12、应用（application）" class="headerlink" title="12、应用（application）"></a>12、应用（application）</h3><p>一组监控项的集合。</p><h3 id="13、web场景（web-scennario）"><a href="#13、web场景（web-scennario）" class="headerlink" title="13、web场景（web scennario）"></a>13、web场景（web scennario）</h3><p>用于检测web站点可用性的一个或多个HTTP请求。</p><h3 id="14、前端（frontend）"><a href="#14、前端（frontend）" class="headerlink" title="14、前端（frontend）"></a>14、前端（frontend）</h3><p>zabbix的web接口。</p><p>通过本次学习，对zabbix有了初步的了解。</p>]]></content>
    
    
    <categories>
      
      <category>网络运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础IT架构</tag>
      
      <tag>zabbix</tag>
      
      <tag>运维监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>winget工具概述</title>
    <link href="/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/08/11/winget%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="WinGet概述"><a href="#WinGet概述" class="headerlink" title="WinGet概述"></a>WinGet概述</h1><p>以下资料来源于微软社区：<a href="https://learn.microsoft.com/zh-cn/windows/package-manager/">https://learn.microsoft.com/zh-cn/windows/package-manager/</a></p><h2 id="什么是WinGet？"><a href="#什么是WinGet？" class="headerlink" title="什么是WinGet？"></a>什么是WinGet？</h2><p>Windows软件包管理器 (WinGet) 是一个工具，帮助用户在Windows系统上发现和安装软件包。项目包括命令行界面 (CLI)、PowerShell模块和组件对象模型 (COM) API。客户端可以访问来自Microsoft Store和WinGet社区库的包,同时支持自建软件源访问。</p><h2 id="什么系统支持使用WinGet？"><a href="#什么系统支持使用WinGet？" class="headerlink" title="什么系统支持使用WinGet？"></a>什么系统支持使用WinGet？</h2><p>Windows 10（1809）以后的版本，会自动安装WinGet工具。在此之前的windows系统需要手动安装，在微软商店。<br>windows 10 （1709）以后都支持使用，但是有一个前提条件，必须更新微软商店，原因是windows11采取了新的微软商店并强制要求所有商店更新至该版本否则不能使用。由于是新系统下的商店，很多依赖项在win10上是没有的，需要手动去安装，具体参考文章windows 10下安装winget。<br>最低支持版本：<br>winget 命令行工具仅在 Windows 10 1709（版本 16299）或更高版本上受支持。 在你首次以用户身份登录 Windows（这会触发 Microsoft Store 将 Windows 程序包管理器注册为异步进程的一部分）之前，winget 工具不可用。 如果最近已经以用户身份进行了首次登录，但发现 winget 尚不可用，则可以打开 PowerShell 并输入以下命令来请求此 winget 注册：Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe。</p><h2 id="WinGet支持哪些安装程序？"><a href="#WinGet支持哪些安装程序？" class="headerlink" title="WinGet支持哪些安装程序？"></a>WinGet支持哪些安装程序？</h2><p>● EXE（具有 Silent 和 SilentWithProgress 标志）<br>● ZIP<br>● INNO<br>● NULLSOFT<br>● MSI<br>● WIX<br>● APPX<br>● MSIX<br>● BURN<br>● PORTABLE</p><h3 id="WinGet的下载"><a href="#WinGet的下载" class="headerlink" title="WinGet的下载"></a>WinGet的下载</h3><p>这里提供一个稳定版本1.8.1522<br>github地址:<a href="https://github.com/microsoft/winget-cli/releases">https://github.com/microsoft/winget-cli/releases</a></p><h2 id="WinGet应用场景"><a href="#WinGet应用场景" class="headerlink" title="WinGet应用场景"></a>WinGet应用场景</h2><p><img src="/img/winget_1.png" alt="winget_1"><br><img src="/img/winget_2.png" alt="winget_2"></p><p>通过以上方法，提升了网络整体安全性，避免了终端用户从不安全网站下载非法应用所带来的内网安全隐患。同时，通过使用批处理脚本实现批量安装应用程序，减少了重复工作，提高了工作效率。</p><h2 id="WinGet软件源的搭建"><a href="#WinGet软件源的搭建" class="headerlink" title="WinGet软件源的搭建"></a>WinGet软件源的搭建</h2><p>准备工作，创建软件清单<br>这里用wingetcreate来实现软件清单创建<br>通过winget命令install wingetcreate（建议连接vpn，这里可能因为网络因素安装失败）<br>寻找需要的软件包，获取其下载链接。<br>通过wingetcreate new install url，来获取清单。<br>可以通过 wingetcreate.exe update –urls 来更新清单。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a></p><h3 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h3><p>由于winget要求软件源必须使用HTTPS，所以需要通过nginx的反向代理来实现访问。<br>安装过程不在这里赘述，贴一张nginx配置文件提供参考。</p><h3 id="搭建Rewinged"><a href="#搭建Rewinged" class="headerlink" title="搭建Rewinged"></a>搭建Rewinged</h3><p>Rewinged 是一个自托管的 winget 包源工具，可以运行在 Linux、Windows、Docker 或云环境中。它通过读取目录中的包清单，并通过 REST API 使这些包可以被 winget 客户端搜索和访问。这使得用户可以创建和管理自己的私有 winget 包源，而无需依赖于云服务，winget 要求 REST 源使用 HTTPS - 不允许明文 HTTP。<br>github地址：<a href="https://github.com/jantari/rewinged">https://github.com/jantari/rewinged</a><br>封装好的程序包地址：<a href="https://github.com/jantari/rewinged/releases">https://github.com/jantari/rewinged/releases</a></p><ol><li>将wingetcreate创建的清单移至服务器，Rewinged 对应目录下（wingetcreate及winget仅可在Windows运行，若操作系统为其他则需要手动填写清单，或将wingetcreate创建的清单移到对应文件夹中）</li><li>通过参数configFile可以将所有参数写成一个json来执行</li><li>命令行执行，运行Rewinged并在后台运行，在rg目录下会有一个日志文件生成<br>nohup .&#x2F;rewinged -configFile &#x2F;rg&#x2F;rewinged.json<br>以下是一个基础的配置文件<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;autoInternalize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/installers&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;autoInternalizeSkip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;https&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsCertificateFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.crt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;httpsPrivateKeyFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/ssl/qunhequnhe.com.key&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:3000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;logLevel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;info&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;manifestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rg/manifests&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>这里要讲一个参数的功能，-autoInternalize开启自动内化，启用后会将软件清单内的下载URL自动下载到本地指定文件夹，从而实现在不连接外网仅连接内网的情况下安装软件。第一次启用该功能会有一个下载软件的过程，在此过程中直接下载则会显示哈希认证不完整，必须等软件包被完整下载才可以正常使用。(从下载url到指定文件夹的这个过程可能会失败，每个软件都需要下载测试一下)<br>这里说一下如果安装包hash校验不通过或者下载不完整怎么处理。<br>首先下载一个完整的安装包，将exe后缀去除使其变为文件，随后打开cmd页面输入命令“winget hash 文件路径”生成文件的哈希值。<br>随后找到rewinged目录下，修改对应软件目录下的installer文件</li></ol><p>替换yaml文件内的哈希值为你下载的软件包哈希</p><p>随后到installers目录下，删除原先的软件包，将新下载的软件名称修改为哈希值（通过哈希值为索引），重启rewinged工具，完成替换。<br>扩展参数<br>这些命令行配置是用于配置和运行 <code>rewinged</code> 应用程序的参数。下面是每个参数的详细解释：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-autoInternalize<br><span class="hljs-bullet">   -</span> 作用：开启自动内部化功能。<br><span class="hljs-bullet">   -</span> 说明：启用此功能后，应用程序会自动将一些内容进行内部处理。<br><br>-autoInternalizePath string<br><span class="hljs-bullet">   -</span> 作用：指定自动内部化安装程序存储的目录。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./installers&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：自动内部化的安装程序将被存储在这个指定的目录中。<br><br>-autoInternalizeSkip string<br><span class="hljs-bullet">   -</span> 作用：指定排除在自动内部化之外的主机名列表。<br><span class="hljs-bullet">   -</span> 说明：可以用逗号或空格分隔多个主机名，这些主机将不进行自动内部化处理。<br><br>-configFile string<br><span class="hljs-bullet">   -</span> 作用：指定一个 JSON 配置文件的路径。<br><span class="hljs-bullet">   -</span> 说明：这个文件是可选的，可以用来提供额外的配置选项。<br><br>-https<br><span class="hljs-bullet">   -</span> 作用：直接从 <span class="hljs-code">`rewinged`</span> 应用程序提供加密的 HTTPS 流量，而无需代理。<br><span class="hljs-bullet">   -</span> 说明：启用此选项后，应用程序将使用 HTTPS 协议。<br><br>-httpsCertificateFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的 Web 服务器证书文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./cert.pem&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：这是应用程序在启用 HTTPS 时使用的证书文件路径。<br><br>-httpsPrivateKeyFile string<br><span class="hljs-bullet">   -</span> 作用：指定 HTTPS 启用时使用的私钥文件。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;./private.key&quot;`</span><br><span class="hljs-bullet">   -</span> <span class="hljs-strong">**说明**</span>：这是应用程序在启用 HTTPS 时使用的私钥文件路径。<br><br>-listen string<br><span class="hljs-bullet">   -</span> 作用：指定 REST API 监听的地址和端口。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;localhost:8080&quot;`</span><br><span class="hljs-bullet">   -</span> 说明：应用程序的 REST API 将在这个地址和端口上进行监听。<br><br>-logLevel string<br><span class="hljs-bullet">   -</span> 作用：设置日志的详细程度。<br><span class="hljs-bullet">   -</span> 默认值：<span class="hljs-code">`&quot;info&quot;`</span><br><span class="hljs-bullet">   -</span> 可选值：<span class="hljs-code">`disable`</span>, <span class="hljs-code">`error`</span>, <span class="hljs-code">`warn`</span>, <span class="hljs-code">`info`</span>, <span class="hljs-code">`debug`</span>, <span class="hljs-code">`trace`</span><br><span class="hljs-bullet">   -</span> 说明：用于控制应用程序的日志输出详细程度。<br><br>-manifestPath string<br><span class="hljs-bullet">    -</span> 作用：指定搜索包清单文件的目录。<br><span class="hljs-bullet">    -</span> 默认值：<span class="hljs-code">`&quot;./packages&quot;`</span><br><span class="hljs-bullet">    -</span> 说明：应用程序将在这个目录中搜索包清单文件。<br><br>-version<br><span class="hljs-bullet">    -</span> 作用：打印版本信息并退出。<br><span class="hljs-bullet">    -</span> 说明：运行时不会启动应用程序，而是打印当前版本信息。<br></code></pre></td></tr></table></figure><h2 id="WinGet工具的使用"><a href="#WinGet工具的使用" class="headerlink" title="WinGet工具的使用"></a>WinGet工具的使用</h2><p>常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">● winget show 软件名  <span class="hljs-comment">#查询软件库中软件信息，该命令支持中文检索</span><br>● winget install --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#安装软件，通过查询软件名可知id号，通过id号来安装，避免因为软件名称混淆导致的安装失败（在WinGet自带的软件库中，就存在QQ、腾讯QQ，以及不同来源的QQ，直接使用软件名安装可能会导致安装失败）</span><br>● winget uninstall --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#卸载软件，使用id号原因同上</span><br>● winget upgrade --<span class="hljs-built_in">id</span>=xxx  <span class="hljs-comment">#更新软件，从软件库中获取更新</span><br>● winget list  <span class="hljs-comment">#查询安装的应用程序</span><br></code></pre></td></tr></table></figure><p>已管理员的身份启动命令行，执行“ winget source add -n qunhe -a <a href="https://winget.qunhequnhe.com/api">https://winget.qunhequnhe.com/api</a> -t “Microsoft.Rest”，随后“winget install 软件名 -s qunhe”即可。<br>这里我写一个bat脚本，能够自动执行添加软件源及安装小酷助手、企业微信、WPS及腾讯会议。有特殊需求直接修改这个脚本即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@echo off<br>echo Installing standard software...<br>winget <span class="hljs-selector-tag">source</span> add -n qunhe -<span class="hljs-selector-tag">a</span> https:<span class="hljs-comment">//winget.qunhequnhe.com/api -t &quot;Microsoft.Rest&quot;</span><br>winget install qunhe<span class="hljs-selector-class">.xiaoku</span> qunhe<span class="hljs-selector-class">.qiyeweixin</span>  KingsoftCorp<span class="hljs-selector-class">.Ltd</span><span class="hljs-selector-class">.WPSOffice</span> Tencent<span class="hljs-selector-class">.WeMeet</span> -s qunhe<br>echo Installation complete.<br></code></pre></td></tr></table></figure><p>功能测试：<br><img src="/img/winget_3.png" alt="winget_3"><br>需要注意以下几点，</p><ol><li>win系统必须带有winget</li><li>必须能解析winget.qunhequnhe.com这个域名如果不可以可能是你的dns服务器设置的有问题，可以尝试使用10.1.102.201<br>拓展参数：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">install</span>    安装给定的程序包<br>  show       显示包的相关信息<br>  source     管理程序包的来源<br>  search     查找并显示程序包的基本信息<br>  list       显示已安装的程序包<br>  upgrade    显示并执行可用升级<br>  uninstall  卸载给定的程序包<br>  hash       哈希安装程序的帮助程序<br>  validate   验证清单文件<br>  settings   打开设置或设置管理员设置<br>  features   显示实验性功能的状态<br>  ex<span class="hljs-keyword">port</span>     导出已安装程序包的列表<br>  <span class="hljs-keyword">import</span>     安装文件中的所有程序包<br>  pin        管理包钉<br>  configure  将系统配置为所需状态<br>  download   从给定的程序包下载安装程序<br>  repair     修复所选包<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>IT技术支持</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>winget</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
